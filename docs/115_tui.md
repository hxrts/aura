# Terminal User Interface (TUI)

This document describes the iocraft-based TUI in `aura-terminal`. It focuses on the current architecture (reactive signals + deterministic state machine) and where code lives.

Demo mode is compiled only with `--features development`.

## Architecture (current)

### Layering

`aura-terminal` follows the shared-logic split:

- **Layer 1 (pure)**: `crates/aura-app` — portable domain logic + signals (`AppCore`)
- **Layer 2 (shared terminal logic)**: `crates/aura-terminal/src/handlers/` — CLI+TUI helpers, persistence glue for the terminal frontend
- **Layer 3 (presentation)**: `crates/aura-terminal/src/tui/` — iocraft UI, deterministic state machine, event bridge

### Two systems: reactive data + deterministic UI state

The TUI intentionally separates:

1. **Reactive domain data** (push-based):
   - All “real data” comes from `aura-app` signals (`core.read(&*SIGNAL)` + `core.subscribe(&*SIGNAL)`).
   - Screens follow a two-phase pattern: **read current → subscribe**.

2. **Deterministic UI state** (pure state machine):
   - Navigation, focus, input buffers, modal queues, toasts, etc. live in `TuiState`.
   - Event handling is pure:
     - `TuiState × TerminalEvent → (TuiState, Vec<TuiCommand>)`
   - Side effects are represented as `TuiCommand` and executed by the runtime.

Key files:
- State machine: `crates/aura-terminal/src/tui/state_machine.rs`
- Runtime driver: `crates/aura-terminal/src/tui/runtime.rs`
- iocraft event adapter: `crates/aura-terminal/src/tui/iocraft_adapter.rs`

### Dispatch model (effects bridge)

User actions are dispatched via `IoContext`:
- `crates/aura-terminal/src/tui/context/io_context.rs`

Commands follow two paths:
- **Intent (journaled)**: `EffectCommand` → `Intent` (via `command_to_intent`) → `AppCore.dispatch(Intent)` → commit facts → emit signals
- **Operational (non-journaled)**: `EffectCommand` handled by the operational handler → emit signals/toasts/errors

Key files:
- Command mapping: `crates/aura-terminal/src/tui/effects/intent_mapper.rs`
- Operational handler: `crates/aura-terminal/src/tui/effects/operational/`
- Dispatch helper: `crates/aura-terminal/src/tui/context/dispatch.rs`

### Modals/toasts/navigation

- Navigation and modal/toast UX is driven by the state machine (queue-based).
- The UI renders based on `TuiState` + reactive data (no ad-hoc modal hook state).

Key files:
- Queue + transitions: `crates/aura-terminal/src/tui/state_machine.rs`
- Props extraction: `crates/aura-terminal/src/tui/props.rs`
- App shell + overlays: `crates/aura-terminal/src/tui/screens/app/shell.rs`, `crates/aura-terminal/src/tui/screens/app/modal_overlays.rs`

## Fullscreen I/O policy

Writing to stderr while iocraft is in fullscreen can corrupt the terminal buffer (e.g., “duplicated” UI rows). The TUI enforces a fullscreen policy:

- **Default**: redirect stderr away from the terminal while fullscreen is active; write tracing to a log file.
- **Debug escape hatch**: set `AURA_TUI_ALLOW_STDIO=1` to disable redirection and file-only tracing behavior.

Key files:
- Type-level stdio tokens + fullscreen wrapper: `crates/aura-terminal/src/handlers/tui_stdio.rs`
- Stderr redirection guard: `crates/aura-terminal/src/tui/fullscreen_stdio.rs`
- Launcher + tracing setup: `crates/aura-terminal/src/handlers/tui.rs`

## Demo mode

Demo mode is compiled only with `--features development` and lives under `crates/aura-terminal/src/demo/`.

Principles:
- Keep demo-only behavior behind feature gates.
- Treat demo as a “data provider” (hints, peer agents) rather than widening production UI types.

## Code map (where things go)

High-level map:

```
crates/aura-terminal/src/
  handlers/
    tui.rs            # TUI launcher (effects-backed persistence + tracing + fullscreen policy)
    tui_stdio.rs      # Fullscreen stdio policy (type-level)
  tui/
    context/          # IoContext + dispatch/toasts/snapshots helpers
    screens/          # One module per screen (block/chat/contacts/...)
      app/            # Root shell + modal overlays + subscriptions
    state_machine.rs  # Deterministic UI model
    runtime.rs        # Executes state-machine commands
    hooks.rs          # AppCoreContext + iocraft helpers
    effects/          # EffectCommand types, mapping, operational handlers
    components/       # Shared widgets (modal, list, inputs, etc.)
```

## Development checklist (TUI changes)

- **Reactive pattern**: screens use `read current → subscribe` on `aura-app` signals; avoid polling.
- **No pre-fullscreen awaits**: keep startup fast; do blocking work after mount via subscriptions.
- **No stdout/stderr during fullscreen**: route through tracing/file sinks; use `AURA_TUI_ALLOW_STDIO=1` only for debugging.
- **Prefer deterministic tests**: extend the state machine tests before adding PTY-style tests.

## Testing

Useful commands:

```bash
just test-crate aura-terminal
# or, offline:
CARGO_NET_OFFLINE=true cargo test -p aura-terminal --tests --offline
```

The preferred test strategy is deterministic tests over PTY-driven tests:
- State machine tests: `crates/aura-terminal/tests/tui_deterministic.rs`
- Broader integration tests: `crates/aura-terminal/tests/tui_e2e.rs`

## See also

- `docs/001_system_architecture.md` (effects, guard chain, signals)
- `docs/003_information_flow_contract.md` (flow budgets + leakage)
- `docs/106_effect_system_and_runtime.md` (effect implementation rules)
