# Aura Messaging Protocol (AMP)

## 1. Scope and Goals

AMP (Aura Messaging Protocol) is a secure asynchronous messaging protocol built specifically for Aura’s architecture. It assumes:

- **Shared state** (facts in joint semilattice journals) is canonical.
- **Secrets** are derived locally from shared state + authority keys.
- Ratchet operations must remain deterministic and recoverable.
- No head-of-line blocking.
- Strong PCS and bounded forward secrecy.

AMP operates within a relational context (a group or relationship) and within a channel (a substream identified by `ChannelId`).

## 2. Terminology and Protocol Parameters

### 2.1 Aura Terms

- **Authority** – Account authority with commitment tree & FROST keys.
- **Relational Context** – Shared state between authorities (`ContextId`).
- **Journal** – CRDT OR-set of facts (monotone, merge via union, deterministic reduction).

### 2.2 AMP Terms

- **Channel** – Messaging substream scoped to a relation context (`ChannelId`).
- **Channel Epoch (`chan_epoch`)** – Per-channel PCS boundary; KDF base.
- **Ratchet Generation (`ratchet_gen`)** – Monotone ratchet position.
- **Skip Window (`W`)** – Out-of-order tolerance. Default: **1024**.
- **Checkpoint** – Journal fact anchoring ratchet and defining valid windows.
- **Alternating Ratchet** – Two overlapping windows active at a boundary.
- **Pending Bump** – Proposed epoch bump awaiting consensus.

## 3. Fact Structures

AMP uses facts inserted into the relational context journal. Facts are monotone. Reduction determines canonical state.

### 3.1 Channel Checkpoint

```rust
pub struct ChannelCheckpoint {
    pub context: ContextId,
    pub channel: ChannelId,
    pub chan_epoch: u64,
    pub base_gen: u64,
    pub window: u32,
    pub ck_commitment: Hash32,
    pub skip_window_override: Option<u32>,
}
```

**Semantics**:

- Reduction chooses one canonical `ChannelCheckpoint` per `(context, channel, chan_epoch)`.
- The valid ratchet generation set is the union of window A and window B, where:
  - A = `[base_gen_a … base_gen_a + window_a]`
  - B = `[base_gen_b … base_gen_b + window_b]`
  - `valid_gen_set = A ∪ B`
- A checkpoint always defines two windows. Checkpoints are enable deterministic recovery and serve as garbage collection anchors.

### 3.2 Proposed and Committed Channel Epoch Bumps

```rust
pub struct ProposedChannelEpochBump {
    pub context: ContextId,
    pub channel: ChannelId,
    pub parent_epoch: u64,
    pub new_epoch: u64,
    pub bump_id: Hash32,
}

pub struct CommittedChannelEpochBump {
    pub context: ContextId,
    pub channel: ChannelId,
    pub parent_epoch: u64,
    pub new_epoch: u64,
    pub chosen_bump_id: Hash32,
    pub consensus_id: ConsensusId,
}
```

**Semantics**:

- Proposed bumps: optimistic ratchet phase transitions.
- Committed bumps: finalized by Aura Consensus (2f+1 witnesses).
- New epoch = parent_epoch + 1, always.
- Only one committed bump per parent epoch.

## 4. Derived Channel State

Reduction yields a `ChannelEpochState` struct containing the current epoch, an optional pending bump, the last checkpoint generation, the current generation, and the skip window size.

```rust
struct ChannelEpochState {
    chan_epoch: u64,
    pending_bump: Option<PendingBump>,
    last_checkpoint_gen: u64,
    current_gen: u64,
    skip_window: u32,
}

struct PendingBump {
    parent_epoch: u64,
    new_epoch: u64,
    bump_id: Hash32,
}
```

### 4.1 Skip Window Computation

The `skip_window` is computed as follows:

1. `checkpoint.skip_window_override`, else
2. channel policy fact (if present), else
3. default **1024**.

### 4.2 Reduce-Before-Send Rule (Critical)

Before sending, a device must:

1. Merge latest facts.
2. Reduce channel state.
3. Use updated `(chan_epoch, ratchet_gen, windows)` to derive keys.

No device may send under stale epochs.

### 4.3 Single Pending Bump Invariant

Only one bump `(e → e+1)` may be pending at a time.


### 4.4 Monotone Epochs

`new_epoch = parent_epoch + 1` always.

### 4.5 What Governs Ratchet Generation

`ratchet_gen` is *not* a local counter. It is always derived from reduced journal state, ensuring that all devices converge to the same ratchet position after merging facts. It advances only when send/receive events occur in a manner consistent with the latest checkpoint and dual-window rules. This guarantees deterministic recovery and prevents drift across devices, even when they reconnect after offline periods.

`new_epoch = parent_epoch + 1` always.

## 5. Channel Epoch Bump Lifecycle

### 5.1 States

A channel has two states. The `Stable(e)` state indicates the epoch is finalized. The `Pending(e → e+1)` state indicates an optimistic bump has been issued and awaits commitment.

### 5.2 Spacing Rule for Routine Bumps

AMP enforces a ratchet-generation spacing rule for routine channel epoch bumps and routine ratchet maintenance. This rule limits how frequently structural ratchet transitions occur, preventing rapid-fire bumps that could outrun dual-window coverage.

*Note: Emergency or suspicious-event bumps bypass this rule to ensure fast post-compromise recovery.*

Let:

- `base_gen` be the anchor generation from the canonical `ChannelCheckpoint`,
- `current_gen` be the current ratchet generation derived from reduced state,
- `W` be the skip window (default `1024`).

A routine bump from epoch e to e+1 is allowed only when `current_gen - base_gen >= W / 2`. With default `W = 1024`, this means `current_gen - base_gen >= 512`.

This spacing ensures structural ratchet transitions do not occur too frequently. Alternating windows always provide complete transitional coverage. No device proposes a new bump before incorporating the previous one once committed. Offline devices remain within safe dual-window tolerance upon resynchronization.

### 5.3 Emergency Bumps

When a potential compromise is detected, AMP permits immediate channel epoch bumps, ignoring the spacing rule entirely. Examples include:

- Multiple AEAD/MAC failures beyond threshold.
- Conflicting ratchet commitments.
- Unexpected message epochs or invalid generation jumps.
- Receipt anomalies suggesting tampering or relay misbehavior.
- Explicit device-compromise signals from the user or authority.

In these cases, a device may emit:

```
ProposedChannelEpochBump { reason = SuspiciousActivity or ConfirmedCompromise }
```

without satisfying the spacing rule.

This fast-path bump:

- Immediately rotates the channel’s KDF base.
- Utilizes dual windows to absorb transitional drift.
- Triggers consensus finalization to ensure global canonicality.
- Restores PCS without waiting for further ratchet advancement.

Suspicious-event bumps may also escalate to context epoch bumps (strong PCS) if warranted.

### Combined Effect

The rules together ensure:

- Routine bumps occur in a controlled, stable pattern.
- Emergency bumps occur immediately and safely.
- Consensus gating still enforces that only one bump can be pending.
- Dual windows guarantee liveness and continuity across transitions.
- No head-of-line blocking, regardless of detection timing.

### 5.4 State Transitions

In the `Stable(e)` state, if the spacing rule is satisfied, the device inserts a `ProposedChannelEpochBump(e→e+1)` and starts consensus to finalize. The device immediately enters the `Pending(e→e+1)` state and uses the new epoch e+1 with alternating windows.

In the `Pending(e → e+1)` state, upon observing a `CommittedChannelEpochBump(e→e+1)`, the device sets `chan_epoch = e+1`. It clears the pending bump. It may emit a new checkpoint in epoch e+1. It returns to the `Stable(e+1)` state. No new bump is allowed during the pending state.

## 6. Ratchet Windows

AMP uses an always-dual window model. Every checkpoint implicitly defines two consecutive skip windows, providing a continuous valid range of 2W ratchet generations.


### 6.1 Checkpoint-Defined Window Layout

Given:

- `base_gen` = anchor generation `G`
- `W` = skip window size (default 1024)

We define two windows automatically:

```
Window A = [ G         … G + W     ]
Window B = [ G + W + 1 … G + 2W    ]
```

Valid generation set for the checkpoint:

```
valid_gen_set = Window A ∪ Window B
```

A checkpoint always implies that both windows are active. This design eliminates boundary issues entirely. No mode switches are required between single and dual window states. The implementation and reasoning are simpler. It provides robust asynchronous tolerance with 2W coverage. It ensures smooth transitions across channel epoch bumps.

### 6.3 Window Shifting

When a new checkpoint is issued:

- The new `base_gen` is chosen far enough ahead (per spacing rule).
- The dual-window layout guarantees overlap with prior windows.
- GC can safely prune older checkpoints when they no longer affect valid generation ranges.

## 7. Sending Messages

### 7.1 Message Header

```rust
struct AmpHeader {
    context: ContextId,
    channel: ChannelId,
    chan_epoch: u64,
    ratchet_gen: u64,
}
```

An `AmpHeader` contains the context identifier, channel identifier, current channel epoch, and current ratchet generation. These fields form the additional data for AEAD encryption.

### 7.2 Send Procedure

Before sending, a device merges new facts and reduces the channel state. It asserts that the current generation is within the valid generation set and the channel epoch is current. If the spacing rule is satisfied and no bump is pending, the device proposes a new bump.

The device derives the message key using a KDF with the channel base key, ratchet generation, and direction. It creates an `AmpHeader` with the context, channel, epoch, and generation. It encrypts the payload with AEAD using the message key and header as additional data. It performs the guard chain to enforce authorization and flow budgets. It advances the local ratchet generation.

## 8. Receiving Messages

When receiving, a device merges new facts and reduces the channel state. It checks that the message's channel epoch is either the current epoch or the pending epoch. It checks that the message's ratchet generation is within the valid generation set.

The device rederives the message key using the same KDF parameters. It decrypts the payload using AEAD decryption with the message key and header as additional data. It advances the local receive ratchet.

Messages outside the valid windows or with epochs too old or no longer supported are rejected.

## 9. Recovery and Garbage Collection

### 9.1 Recovery

To recover, a device loads the relational context journal. It reduces to the latest committed channel epoch, the latest checkpoint, and the skip window. It rederives channel base key from `(ContextRootKey, ChannelId, chan_epoch)`. It rederives ratchet state from the checkpoint and window generations.

### 9.2 Garbage Collection

AMP garbage collection maintains protocol safety while reclaiming storage for obsolete facts. GC operates on three fact types: checkpoints, proposed bumps, and committed bumps.

#### Safe Pruning Rules

**Checkpoints:**
- A checkpoint at generation `G` with window `W` can be pruned if and only if:
  - A newer checkpoint exists at generation `G'` where `G' > G + 2W`
  - The newer checkpoint's dual-window coverage `[G' … G' + 2W]` does not overlap with `[G … G + 2W]`
  - All messages within the old checkpoint's window have been processed or are beyond the recovery horizon

**Proposed Bumps:**
- A `ProposedChannelEpochBump(e → e+1)` can be pruned when:
  - A `CommittedChannelEpochBump(e → e+1)` exists (superseded by finalized bump)
  - OR epoch `e+2` is committed (proposal became stale)

**Committed Bumps:**
- Committed bumps are retained as consensus evidence
- Can be pruned only during full snapshot compaction when all devices have confirmed synchronization beyond that epoch

#### Pruning Boundary Computation

The safe pruning boundary for checkpoints is computed as:

```
safe_prune_gen = max_checkpoint_gen - (2 * W) - SAFETY_MARGIN
```

Where:
- `max_checkpoint_gen` is the highest generation with a checkpoint
- `W` is the skip window size (default 1024)
- `SAFETY_MARGIN` is an additional buffer (recommended: W/2 = 512 generations)

Checkpoints at `base_gen < safe_prune_gen` can be safely removed.

#### GC Triggers

Garbage collection runs when:
- Journal size exceeds configured threshold
- Checkpoint count exceeds maximum (default: 10 active checkpoints per channel)
- Manual compaction requested
- Snapshot creation initiated

#### Integration with Aura Snapshot GC

AMP GC coordinates with Aura's snapshot system:
- Checkpoints pruned before snapshot creation are not included in snapshot
- Snapshot restoration reconstructs only retained checkpoints
- Post-snapshot, older facts before the snapshot epoch can be pruned
- Cross-device coordination ensures no device relies on pruned state

## 10. Security Properties

### 10.1 Forward Secrecy

Forward secrecy is bounded by the skip window size `W=1024` within each epoch. Older epochs use independent base keys.

### 10.2 Post-Compromise Security

- Channel epoch bumps ← healing compromise of channel secret state.
- Context epoch bumps ← healing compromise of context state (stronger PCS).

### 10.3 No Head-of-Line Blocking

The protocol accepts out-of-order messages up to W generations. Dual windows absorb boundary drift.

### 10.4 No Ratchet Forks

Consensus finalizes each epoch step. The epoch chain is always linear and monotone.

### 10.5 Deterministic Recovery

Checkpoints anchor the ratchet. Facts represent all shared state. Keys are always rederived deterministically.

## 11. Governance

The `skip_window` size `W` is governable via policy facts. Bump cadence and post-compromise security triggers can be governed by context policies.

## 12. Failure Modes

AMP drops messages only when they fall outside the cryptographically safe envelope defined by epochs, windows, and integrity checks. These failures are intentional safeguards rather than protocol instability.

### 12.1 Generation Out of Window

A message is dropped if its `ratchet_gen` lies outside the valid generation set defined by the active checkpoint:

```
valid_gen_set = [base_gen … base_gen + W] ∪ [base_gen + W + 1 … base_gen + 2W]
```

Causes include:

- Sender using stale or malformed ratchet state.
- Message so old that the checkpoint window has moved past it (post-GC aging).
- Attacker crafting invalid generations.

### 12.2 Epoch Mismatch

Messages are rejected when `header.chan_epoch` is inconsistent with the locally reduced epoch state:

- Too old (below the earliest supported epoch).
- Unknown or non-linear epoch (does not match the canonical bump chain).
- Replay of ciphertext from a retired epoch.

### 12.3 AEAD or MAC Failure

If AEAD decryption fails messages are dropped. Repeated failures contribute to suspicious-event classification and may trigger emergency PCS.

### 12.4 Beyond Recovery Horizon

Messages older than the current checkpoint's 2W generation window cannot be decrypted because older checkpoints have been garbage collected. Local ratchet state cannot be reconstructed far enough back. This is an intentional forward secrecy and retention trade-off.

### 12.5 Policy-Enforced Invalidity

After context epoch bumps or high-severity post-compromise security events, messages from previous context epochs are intentionally dropped to prevent replay or ambiguity.

These are the only scenarios in which AMP rejects messages under correct operation. All other cases are absorbed by dual-window tolerance, consensus finality, and reduce-before-send guarantees.
