//! Integration tests for ITF trace replay through GenerativeSimulator
//!
//! These tests demonstrate loading ITF traces generated by Quint and replaying them
//! through the Aura effect system.
#![allow(clippy::expect_used)]

use std::collections::HashMap;
use std::path::Path;

use aura_simulator::quint::{
    capability_properties_registry, ActionRegistry, GenerativeSimulator, GenerativeSimulatorConfig,
    ITFLoader, ITFTraceBuilder, NoOpHandler, QuintSimulationState,
};

// =============================================================================
// Test Helpers
// =============================================================================

fn create_test_registry() -> ActionRegistry {
    let mut registry = ActionRegistry::new();
    registry.register(NoOpHandler::new("step"));
    registry.register(NoOpHandler::new("init"));
    registry.register(NoOpHandler::new("startConsensus"));
    registry.register(NoOpHandler::new("submitWitnessShare"));
    registry.register(NoOpHandler::new("triggerFallback"));
    registry.register(NoOpHandler::new("failConsensus"));
    registry.register(NoOpHandler::new("localWrite"));
    registry.register(NoOpHandler::new("createDelta"));
    registry.register(NoOpHandler::new("applyDelta"));
    registry.register(NoOpHandler::new("transitionEpoch"));
    registry.register(NoOpHandler::new("createReceipt"));
    registry.register(NoOpHandler::new("createOperation"));
    registry
}

fn create_test_state() -> QuintSimulationState {
    let mut state = QuintSimulationState::new();
    let ctx = aura_core::types::ContextId::new_from_entropy([1u8; 32]);
    let auth = aura_core::types::AuthorityId::new_from_entropy([2u8; 32]);
    state.init_context(ctx, auth, 100);
    state
}

// =============================================================================
// ITF Loading Tests
// =============================================================================

#[test]
fn test_load_consensus_trace_from_file() {
    let trace_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|path| path.parent())
        .expect("missing manifest ancestors")
        .join("traces/consensus.itf.json");

    if !trace_path.exists() {
        println!("Skipping test: consensus trace not found at {trace_path:?}");
        return;
    }

    let trace = ITFLoader::load_from_file(&trace_path).expect("Failed to load consensus trace");

    assert!(!trace.states.is_empty(), "Trace should have states");
    assert!(
        trace.vars.contains(&"instances".to_string()),
        "Should have instances var"
    );
    assert!(
        trace.vars.contains(&"committedFacts".to_string()),
        "Should have committedFacts var"
    );

    println!("Loaded consensus trace with {} states", trace.states.len());
}

#[test]
fn test_load_anti_entropy_trace_from_file() {
    let trace_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|path| path.parent())
        .expect("missing manifest ancestors")
        .join("traces/anti_entropy.itf.json");

    if !trace_path.exists() {
        println!("Skipping test: anti_entropy trace not found at {trace_path:?}");
        return;
    }

    let trace = ITFLoader::load_from_file(&trace_path).expect("Failed to load anti_entropy trace");

    assert!(!trace.states.is_empty());
    assert!(trace.vars.contains(&"nodeStates".to_string()));
    assert!(trace.vars.contains(&"pendingDeltas".to_string()));

    println!(
        "Loaded anti_entropy trace with {} states",
        trace.states.len()
    );
}

#[test]
fn test_load_epochs_trace_from_file() {
    let trace_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|path| path.parent())
        .expect("missing manifest ancestors")
        .join("traces/epochs.itf.json");

    if !trace_path.exists() {
        println!("Skipping test: epochs trace not found at {trace_path:?}");
        return;
    }

    let trace = ITFLoader::load_from_file(&trace_path).expect("Failed to load epochs trace");

    assert!(!trace.states.is_empty());
    assert!(trace.vars.contains(&"currentEpoch".to_string()));
    assert!(trace.vars.contains(&"receipts".to_string()));

    println!("Loaded epochs trace with {} states", trace.states.len());
}

// =============================================================================
// Simulation Sequence Tests
// =============================================================================

#[test]
fn test_convert_trace_to_simulation_sequence() {
    let trace = ITFTraceBuilder::new("test_consensus.qnt")
        .description("Test consensus trace")
        .vars(["instances", "committedFacts", "globalWitnesses"])
        .add_state({
            let mut m = HashMap::new();
            m.insert("instances".to_string(), serde_json::json!({}));
            m.insert("committedFacts".to_string(), serde_json::json!([]));
            m.insert(
                "globalWitnesses".to_string(),
                serde_json::json!(["w1", "w2", "w3"]),
            );
            m
        })
        .add_state({
            let mut m = HashMap::new();
            m.insert(
                "instances".to_string(),
                serde_json::json!({
                    "cns1": {
                        "cid": "cns1",
                        "phase": "FastPathActive",
                        "proposals": [],
                        "threshold": 2
                    }
                }),
            );
            m.insert("committedFacts".to_string(), serde_json::json!([]));
            m.insert(
                "globalWitnesses".to_string(),
                serde_json::json!(["w1", "w2", "w3"]),
            );
            m
        })
        .add_state({
            let mut m = HashMap::new();
            m.insert(
                "instances".to_string(),
                serde_json::json!({
                    "cns1": {
                        "cid": "cns1",
                        "phase": "FastPathActive",
                        "proposals": [{"witness": "w1"}],
                        "threshold": 2
                    }
                }),
            );
            m.insert("committedFacts".to_string(), serde_json::json!([]));
            m.insert(
                "globalWitnesses".to_string(),
                serde_json::json!(["w1", "w2", "w3"]),
            );
            m
        })
        .build();

    let sequence = ITFLoader::to_simulation_sequence(&trace);

    assert_eq!(sequence.steps.len(), 2);
    assert_eq!(sequence.steps[0].action, "startConsensus");
    // Second step modifies proposals within instances, inferred as startConsensus again
    // (our simple inference looks at top-level var changes)

    println!("Converted to {} simulation steps", sequence.steps.len());
    for step in &sequence.steps {
        println!("  Step {}: {}", step.index, step.action);
    }
}

// =============================================================================
// Generative Simulator Replay Tests
// =============================================================================

#[tokio::test]
async fn test_replay_programmatic_trace() {
    let registry = create_test_registry();
    let config = GenerativeSimulatorConfig {
        max_steps: 100,
        record_trace: true,
        verbose: false,
        exploration_seed: Some(42),
    };

    let simulator = GenerativeSimulator::new(registry, config);
    let initial_state = create_test_state();

    // Create a trace with action metadata
    let trace = ITFTraceBuilder::new("test.qnt")
        .vars(["instances", "committedFacts"])
        .add_state_with_action(
            {
                let mut m = HashMap::new();
                m.insert("instances".to_string(), serde_json::json!({}));
                m.insert("committedFacts".to_string(), serde_json::json!([]));
                m
            },
            "init",
            None,
        )
        .add_state_with_action(
            {
                let mut m = HashMap::new();
                m.insert(
                    "instances".to_string(),
                    serde_json::json!({"cns1": {"phase": "FastPathActive"}}),
                );
                m.insert("committedFacts".to_string(), serde_json::json!([]));
                m
            },
            "startConsensus",
            None,
        )
        .build();

    let result = simulator.replay_trace(&trace, initial_state).await;

    match result {
        Ok(sim_result) => {
            println!("Replay completed with {} steps", sim_result.step_count);
            assert!(sim_result.success, "Replay should succeed");
        }
        Err(e) => {
            // Some actions may fail due to missing handlers - this is expected for NoOp handlers
            println!("Replay returned error (expected for NoOp): {e}");
        }
    }
}

#[tokio::test]
async fn test_explore_with_registry() {
    let registry = capability_properties_registry();
    let config = GenerativeSimulatorConfig {
        max_steps: 10,
        record_trace: true,
        verbose: false,
        exploration_seed: Some(12345),
    };

    let simulator = GenerativeSimulator::new(registry, config);
    let initial_state = create_test_state();

    let result = simulator.explore(initial_state, Some(12345)).await;

    assert!(result.is_ok(), "Exploration should succeed");

    let sim_result = result.expect("exploration should succeed");
    println!(
        "Exploration completed: {} steps, success={}",
        sim_result.step_count, sim_result.success
    );
}

// =============================================================================
// End-to-End: Load and Replay Real Trace
// =============================================================================

#[tokio::test]
async fn test_load_and_analyze_consensus_trace() {
    let trace_path = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|path| path.parent())
        .expect("missing manifest ancestors")
        .join("traces/consensus.itf.json");

    if !trace_path.exists() {
        println!("Skipping: consensus trace not found");
        return;
    }

    let trace = ITFLoader::load_from_file(&trace_path).expect("Failed to load trace");

    // Analyze the trace
    println!("\n=== Consensus Trace Analysis ===");
    println!("Source: {}", trace.meta.source);
    println!("States: {}", trace.states.len());
    println!("Variables: {:?}", trace.vars);

    // Convert to simulation sequence
    let sequence = ITFLoader::to_simulation_sequence(&trace);

    println!("\nInferred actions:");
    for step in &sequence.steps {
        println!("  [{:2}] {}", step.index, step.action);
    }

    // Count action types
    let mut action_counts: HashMap<String, usize> = HashMap::new();
    for step in &sequence.steps {
        *action_counts.entry(step.action.clone()).or_insert(0) += 1;
    }

    println!("\nAction distribution:");
    for (action, count) in &action_counts {
        println!("  {action}: {count}");
    }
}

#[tokio::test]
async fn test_load_and_analyze_all_traces() {
    let traces_dir = Path::new(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|path| path.parent())
        .expect("missing manifest ancestors")
        .join("traces");

    if !traces_dir.exists() {
        println!("Skipping: traces directory not found");
        return;
    }

    let trace_files = [
        "cap_props.itf.json",
        "frost.itf.json",
        "dkg.itf.json",
        "consensus.itf.json",
        "cross_interaction.itf.json",
        "anti_entropy.itf.json",
        "epochs.itf.json",
    ];

    println!("\n=== All Traces Analysis ===\n");

    for file in &trace_files {
        let path = traces_dir.join(file);
        if !path.exists() {
            println!("{file}: NOT FOUND");
            continue;
        }

        match ITFLoader::load_from_file(&path) {
            Ok(trace) => {
                let sequence = ITFLoader::to_simulation_sequence(&trace);
                println!(
                    "{file}: {} states, {} inferred actions",
                    trace.states.len(),
                    sequence.steps.len()
                );
            }
            Err(e) => {
                println!("{file}: LOAD ERROR - {e}");
            }
        }
    }
}
