//! Simple DKD Test
//!
//! This test verifies the core DKD functionality using the AuraProtocolHandler
//! middleware pattern for composable and type-safe protocol execution.

use aura_crypto::Effects;
use aura_journal::{AccountLedger, AccountState, DeviceMetadata, DeviceType};
use aura_protocol::{
    handlers::InMemoryHandler,
    middleware::{
        AuraProtocolHandler, CapabilityMiddleware, ErrorRecoveryMiddleware, MetricsMiddleware,
        ProtocolError, ProtocolResult, SessionMiddleware, TracingMiddleware,
    },
};
use aura_types::{AccountId, DeviceId};
use ed25519_dalek::SigningKey;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

/// DKD protocol message for testing
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DkdMessage {
    pub app_id: String,
    pub context: String,
    pub threshold: usize,
    pub participants: Vec<DeviceId>,
}

/// Test protocol handler implementation for DKD
pub struct DkdProtocolHandler {
    device_id: DeviceId,
    sessions: HashMap<Uuid, DkdSession>,
    message_queue: HashMap<DeviceId, Vec<DkdMessage>>,
}

/// DKD session information
#[derive(Debug, Clone)]
pub struct DkdSession {
    pub session_id: Uuid,
    pub participants: Vec<DeviceId>,
    pub app_id: String,
    pub context: String,
    pub threshold: usize,
    pub started_at: u64,
}

impl DkdProtocolHandler {
    pub fn new(device_id: DeviceId) -> Self {
        Self {
            device_id,
            sessions: HashMap::new(),
            message_queue: HashMap::new(),
        }
    }
}

#[async_trait::async_trait]
impl AuraProtocolHandler for DkdProtocolHandler {
    type DeviceId = DeviceId;
    type SessionId = Uuid;
    type Message = DkdMessage;

    async fn send_message(&mut self, to: Self::DeviceId, msg: Self::Message) -> ProtocolResult<()> {
        self.message_queue
            .entry(to)
            .or_insert_with(Vec::new)
            .push(msg);
        Ok(())
    }

    async fn receive_message(&mut self, from: Self::DeviceId) -> ProtocolResult<Self::Message> {
        if let Some(messages) = self.message_queue.get_mut(&from) {
            if let Some(message) = messages.pop() {
                return Ok(message);
            }
        }

        // Return default message if no messages in queue
        Ok(DkdMessage {
            app_id: "default".to_string(),
            context: "default".to_string(),
            threshold: 2,
            participants: vec![],
        })
    }

    async fn start_session(
        &mut self,
        participants: Vec<Self::DeviceId>,
        protocol_type: String,
        metadata: HashMap<String, String>,
    ) -> ProtocolResult<Self::SessionId> {
        let session_id = Uuid::new_v4();

        let app_id = metadata
            .get("app_id")
            .cloned()
            .unwrap_or_else(|| "test_app".to_string());
        let context = metadata
            .get("context")
            .cloned()
            .unwrap_or_else(|| "test_context".to_string());
        let threshold = metadata
            .get("threshold")
            .and_then(|s| s.parse().ok())
            .unwrap_or(2);

        let session = DkdSession {
            session_id,
            participants,
            app_id,
            context,
            threshold,
            started_at: current_timestamp
                .duration_since(std::time::UNIX_EPOCH)
                .unwrap()
                .as_secs(),
        };

        self.sessions.insert(session_id, session);
        Ok(session_id)
    }

    async fn end_session(&mut self, session_id: Self::SessionId) -> ProtocolResult<()> {
        self.sessions.remove(&session_id);
        Ok(())
    }

    async fn get_session_info(
        &mut self,
        session_id: Self::SessionId,
    ) -> ProtocolResult<aura_protocol::middleware::SessionInfo> {
        if let Some(session) = self.sessions.get(&session_id) {
            let mut metadata = HashMap::new();
            metadata.insert("app_id".to_string(), session.app_id.clone());
            metadata.insert("context".to_string(), session.context.clone());
            metadata.insert("threshold".to_string(), session.threshold.to_string());

            Ok(aura_protocol::middleware::SessionInfo {
                session_id,
                participants: session.participants.clone(),
                protocol_type: "DKD".to_string(),
                started_at: session.started_at,
                metadata,
            })
        } else {
            Err(ProtocolError::Session {
                message: format!("Session not found: {}", session_id),
            })
        }
    }

    async fn list_sessions(
        &mut self,
    ) -> ProtocolResult<Vec<aura_protocol::middleware::SessionInfo>> {
        let mut sessions = Vec::new();
        for session in self.sessions.values() {
            let mut metadata = HashMap::new();
            metadata.insert("app_id".to_string(), session.app_id.clone());
            metadata.insert("context".to_string(), session.context.clone());
            metadata.insert("threshold".to_string(), session.threshold.to_string());

            sessions.push(aura_protocol::middleware::SessionInfo {
                session_id: session.session_id,
                participants: session.participants.clone(),
                protocol_type: "DKD".to_string(),
                started_at: session.started_at,
                metadata,
            });
        }
        Ok(sessions)
    }

    async fn verify_capability(
        &mut self,
        _operation: &str,
        _resource: &str,
        _context: HashMap<String, String>,
    ) -> ProtocolResult<bool> {
        // For testing, always allow operations
        Ok(true)
    }

    async fn create_authorization_proof(
        &mut self,
        _operation: &str,
        _resource: &str,
        _context: HashMap<String, String>,
    ) -> ProtocolResult<Vec<u8>> {
        // Return dummy proof for testing
        Ok(vec![0x01, 0x02, 0x03])
    }

    fn device_id(&self) -> Self::DeviceId {
        self.device_id
    }
}

/// Build a DKD middleware stack for testing
pub fn build_dkd_middleware_stack(
    base_handler: DkdProtocolHandler,
) -> impl AuraProtocolHandler<DeviceId = DeviceId, SessionId = Uuid, Message = DkdMessage> {
    let handler = SessionMiddleware::new(base_handler);
    let handler = CapabilityMiddleware::new(handler);
    let handler = ErrorRecoveryMiddleware::new(handler);
    let handler = MetricsMiddleware::new(handler);
    TracingMiddleware::new(handler)
}

/// Helper function to create a test AccountState
fn create_test_account_state(effects: &Effects) -> AccountState {
    let account_id = AccountId(Uuid::new_v4());
    let key_bytes = effects.random_bytes::<32>();
    let signing_key = SigningKey::from_bytes(&key_bytes);
    let group_public_key = signing_key.verifying_key();

    let device_metadata = DeviceMetadata {
        device_id: DeviceId(Uuid::new_v4()),
        device_name: "Test Device".to_string(),
        device_type: DeviceType::Native,
        public_key: signing_key.verifying_key(),
        added_at: effects.now().unwrap_or(0),
        last_seen: effects.now().unwrap_or(0),
        dkd_commitment_proofs: std::collections::BTreeMap::new(),
        next_nonce: 1,
        used_nonces: std::collections::BTreeSet::new(),
    };

    AccountState::new(account_id, group_public_key, device_metadata, 2, 3)
}

#[tokio::test]
async fn test_dkd_middleware_execution() {
    println!("=== DKD Middleware Test ===");

    // Create test devices and participants
    let device_id = DeviceId(Uuid::from_u128(67890));
    let participants = vec![
        device_id,
        DeviceId(Uuid::from_u128(11111)),
        DeviceId(Uuid::from_u128(22222)),
    ];

    // Create deterministic effects for testing
    let effects = Effects::deterministic(54321, 0);

    // Create test ledger with initial state
    let initial_state = create_test_account_state(&effects);
    let ledger = Arc::new(RwLock::new(
        AccountLedger::new(initial_state).expect("Failed to create test ledger"),
    ));

    // Create protocol handler with middleware stack
    let base_handler = DkdProtocolHandler::new(device_id);
    let mut handler = build_dkd_middleware_stack(base_handler);

    println!("[OK] Created DKD protocol handler with middleware stack");

    // Setup the handler
    handler.setup().await.expect("Failed to setup handler");

    // Test session creation
    let mut session_metadata = HashMap::new();
    session_metadata.insert("app_id".to_string(), "test-app".to_string());
    session_metadata.insert("context".to_string(), "test-context".to_string());
    session_metadata.insert("threshold".to_string(), "2".to_string());

    let session_id = handler
        .start_session(participants.clone(), "DKD".to_string(), session_metadata)
        .await
        .expect("Failed to start DKD session");

    println!("[OK] Started DKD session: {}", session_id);

    // Test session info retrieval
    let session_info = handler
        .get_session_info(session_id)
        .await
        .expect("Failed to get session info");

    assert_eq!(session_info.protocol_type, "DKD");
    assert_eq!(session_info.participants, participants);
    assert_eq!(session_info.metadata.get("app_id").unwrap(), "test-app");
    assert_eq!(
        session_info.metadata.get("context").unwrap(),
        "test-context"
    );

    println!("[OK] Session info retrieved successfully");

    // Test DKD message passing
    let dkd_message = DkdMessage {
        app_id: "test-app".to_string(),
        context: "test-context".to_string(),
        threshold: 2,
        participants: participants.clone(),
    };

    // Send message to each participant
    for participant in &participants[1..] {
        handler
            .send_message(*participant, dkd_message.clone())
            .await
            .expect("Failed to send DKD message");
    }

    println!("[OK] Sent DKD messages to participants");

    // Test receiving messages
    for participant in &participants[1..] {
        let received_message = handler
            .receive_message(*participant)
            .await
            .expect("Failed to receive DKD message");

        assert_eq!(received_message.app_id, dkd_message.app_id);
        assert_eq!(received_message.context, dkd_message.context);
        assert_eq!(received_message.threshold, dkd_message.threshold);
    }

    println!("[OK] Received and validated DKD messages");

    // Test capability verification
    let mut capability_context = HashMap::new();
    capability_context.insert("session_id".to_string(), session_id.to_string());

    let can_derive = handler
        .verify_capability("derive_key", "dkd", capability_context)
        .await
        .expect("Failed to verify capability");

    assert!(can_derive);
    println!("[OK] Capability verification passed");

    // Test session cleanup
    handler
        .end_session(session_id)
        .await
        .expect("Failed to end session");

    // Verify session is gone
    assert!(handler.get_session_info(session_id).await.is_err());
    println!("[OK] Session cleaned up successfully");

    // Teardown the handler
    handler
        .teardown()
        .await
        .expect("Failed to teardown handler");

    println!("=== Test PASSED: DKD Middleware Execution ===");
}

#[tokio::test]
async fn test_dkd_deterministic_setup() {
    println!("\n=== DKD Deterministic Setup Test ===");

    // Test that the same parameters produce the same handler setup
    let device_id = DeviceId(Uuid::from_u128(22222));

    for i in 0..3 {
        println!("  Run {}: Creating handler...", i + 1);

        let base_handler = DkdProtocolHandler::new(device_id);
        let mut handler = build_dkd_middleware_stack(base_handler);

        // Setup handler
        handler.setup().await.expect("Failed to setup handler");

        // Verify consistent setup
        assert_eq!(handler.device_id(), device_id);

        println!("  Run {}: Handler created consistently", i + 1);

        // Teardown handler
        handler
            .teardown()
            .await
            .expect("Failed to teardown handler");
    }

    println!("[OK] All {} runs produced consistent handler setup", 3);
    println!("=== Deterministic Setup Test PASSED ===");
}

#[tokio::test]
async fn test_dkd_different_contexts() {
    println!("\n=== DKD Different Contexts Test ===");

    // Test that different contexts can be set up properly
    let device_id = DeviceId(Uuid::from_u128(44444));
    let participants = vec![device_id];

    let contexts = vec![
        ("context-1", "app-1"),
        ("context-2", "app-2"),
        ("different-app", "app-3"),
    ];

    for (i, (context, app_id)) in contexts.iter().enumerate() {
        println!(
            "  Testing context {}: app_id={}, context={}",
            i + 1,
            app_id,
            context
        );

        let base_handler = DkdProtocolHandler::new(device_id);
        let mut handler = build_dkd_middleware_stack(base_handler);

        // Setup handler
        handler.setup().await.expect("Failed to setup handler");

        // Create session with specific context
        let mut session_metadata = HashMap::new();
        session_metadata.insert("app_id".to_string(), app_id.to_string());
        session_metadata.insert("context".to_string(), context.to_string());
        session_metadata.insert("threshold".to_string(), "2".to_string());

        let session_id = handler
            .start_session(participants.clone(), "DKD".to_string(), session_metadata)
            .await
            .expect("Failed to start session");

        // Verify session was created with correct context
        let session_info = handler
            .get_session_info(session_id)
            .await
            .expect("Failed to get session info");

        assert_eq!(session_info.metadata.get("app_id").unwrap(), app_id);
        assert_eq!(session_info.metadata.get("context").unwrap(), context);

        println!("  Context {}: Session created successfully", i + 1);

        // Cleanup
        handler
            .end_session(session_id)
            .await
            .expect("Failed to end session");
        handler
            .teardown()
            .await
            .expect("Failed to teardown handler");
    }

    println!(
        "[OK] All {} contexts can create DKD sessions",
        contexts.len()
    );
    println!("=== Different Contexts Test PASSED ===");
}

#[tokio::test]
async fn test_dkd_middleware_stack_composition() {
    println!("\n=== DKD Middleware Stack Composition Test ===");

    let device_id = DeviceId::new();
    let base_handler = DkdProtocolHandler::new(device_id);
    let mut handler = build_dkd_middleware_stack(base_handler);

    // Test that middleware stack is properly composed
    handler
        .setup()
        .await
        .expect("Failed to setup middleware stack");

    // Test that all middleware layers are active
    let health_check = handler.health_check().await.expect("Health check failed");
    assert!(health_check);

    // Test capabilities are properly layered
    let can_operate = handler
        .verify_capability("test", "test", HashMap::new())
        .await
        .expect("Capability check failed");
    assert!(can_operate);

    handler
        .teardown()
        .await
        .expect("Failed to teardown middleware stack");

    println!("[OK] Middleware stack composition test passed");
    println!("=== Middleware Stack Composition Test PASSED ===");
}
