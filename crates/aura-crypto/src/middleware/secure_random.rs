//! TODO fix - Simplified Secure Random Validation
//!
//! **CLEANUP**: TODO fix - Simplified from complex middleware with entropy health monitoring
//! to basic validation-only approach. Quality assurance moved to effects layer.

use super::{CryptoContext, CryptoHandler, CryptoMiddleware, CryptoOperation};
use crate::{CryptoError, Result};

/// Basic secure random configuration
#[derive(Debug, Clone)]
pub struct RandomConfig {
    /// Maximum bytes per single request
    pub max_bytes_per_request: usize,
    /// Minimum bytes per request (avoid trivial requests)
    pub min_bytes_per_request: usize,
}

impl Default for RandomConfig {
    fn default() -> Self {
        Self {
            max_bytes_per_request: 1024 * 1024, // 1MB max
            min_bytes_per_request: 1,           // At least 1 byte
        }
    }
}

/// TODO fix - Simplified secure random middleware for basic validation
pub struct SecureRandomMiddleware {
    config: RandomConfig,
}

impl SecureRandomMiddleware {
    /// Create new secure random middleware
    pub fn new(config: RandomConfig) -> Self {
        Self { config }
    }

    /// Validate random generation parameters
    fn validate_random_params(&self, num_bytes: usize) -> Result<()> {
        if num_bytes < self.config.min_bytes_per_request {
            return Err(CryptoError::invalid("Requested bytes below minimum"));
        }

        if num_bytes > self.config.max_bytes_per_request {
            return Err(CryptoError::invalid("Requested bytes exceeds maximum"));
        }

        // Check for reasonable upper bounds to prevent DoS
        if num_bytes > 10_000_000 {
            // 10MB absolute maximum
            return Err(CryptoError::invalid(
                "Requested bytes exceeds absolute maximum",
            ));
        }

        Ok(())
    }

    /// Basic quality check on generated bytes (simple sanity checks only)
    fn basic_quality_check(&self, bytes: &[u8]) -> Result<()> {
        if bytes.is_empty() {
            return Err(CryptoError::crypto("Generated bytes are empty"));
        }

        // Check for obvious patterns (all same byte)
        if bytes.len() > 1 {
            let first = bytes[0];
            if bytes.iter().all(|&b| b == first) {
                return Err(CryptoError::crypto("Generated bytes have obvious pattern"));
            }
        }

        Ok(())
    }
}

impl CryptoMiddleware for SecureRandomMiddleware {
    fn process(
        &self,
        operation: CryptoOperation,
        context: &CryptoContext,
        next: &dyn CryptoHandler,
    ) -> Result<serde_json::Value> {
        match operation {
            CryptoOperation::GenerateRandom { num_bytes } => {
                // Validate parameters
                self.validate_random_params(num_bytes)?;

                // Pass to next handler
                let result = next.handle(CryptoOperation::GenerateRandom { num_bytes }, context)?;

                // Basic quality check on result if we can extract the bytes
                if let Some(bytes_value) = result.get("bytes") {
                    if let Some(bytes_str) = bytes_value.as_str() {
                        if let Ok(bytes) = hex::decode(bytes_str) {
                            self.basic_quality_check(&bytes)?;
                        }
                    }
                }

                Ok(result)
            }
            other => next.handle(other, context),
        }
    }

    fn name(&self) -> &str {
        "SecureRandomMiddleware"
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_valid_parameters() {
        let middleware = SecureRandomMiddleware::new(RandomConfig::default());

        assert!(middleware.validate_random_params(32).is_ok());
        assert!(middleware.validate_random_params(1024).is_ok());
    }

    #[test]
    fn test_invalid_parameters() {
        let config = RandomConfig {
            min_bytes_per_request: 4,
            max_bytes_per_request: 1024,
        };
        let middleware = SecureRandomMiddleware::new(config);

        // Too few bytes
        assert!(middleware.validate_random_params(2).is_err());

        // Too many bytes
        assert!(middleware.validate_random_params(2048).is_err());

        // Way too many bytes (DoS protection)
        assert!(middleware.validate_random_params(100_000_000).is_err());
    }

    #[test]
    fn test_quality_checks() {
        let middleware = SecureRandomMiddleware::new(RandomConfig::default());

        // Good random bytes
        let good_bytes = vec![0x12, 0x34, 0x56, 0x78];
        assert!(middleware.basic_quality_check(&good_bytes).is_ok());

        // Empty bytes
        let empty_bytes = vec![];
        assert!(middleware.basic_quality_check(&empty_bytes).is_err());

        // All same bytes (obvious pattern)
        let same_bytes = vec![0x42; 8];
        assert!(middleware.basic_quality_check(&same_bytes).is_err());

        // Single byte (should be OK)
        let single_byte = vec![0x42];
        assert!(middleware.basic_quality_check(&single_byte).is_ok());
    }
}
