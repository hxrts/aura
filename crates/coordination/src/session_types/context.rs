//! Session Type States for Protocol Context (Refactored with Macros)
//!
//! This module defines session types for the ProtocolContext execution environment,
//! providing compile-time safety for protocol execution phases and instruction flows.

use crate::session_types::wrapper::{SessionProtocol, SessionTypedProtocol};
use aura_journal::{Event, ProtocolType};
use aura_types::DeviceId;
use serde::{Deserialize, Serialize};
use session_types::witnesses::RuntimeWitness;
use session_types::SessionState;
use session_types::*; // Import macros
use std::collections::BTreeMap;
use uuid::Uuid;

// ========== Protocol execution types ==========

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Instruction {
    WriteToLedger(Box<aura_journal::Event>),
    AwaitEvent {
        event_type: String,
        timeout: u64,
    },
    AwaitThreshold {
        threshold: u16,
        timeout: u64,
    },
    RunSubProtocol {
        protocol_type: String,
        parameters: BTreeMap<String, String>,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum InstructionResult {
    EventWritten { event_id: Uuid },
    EventReceived { event: Box<aura_journal::Event> },
    ThresholdMet { count: u16 },
    SubProtocolComplete { result: String },
    Error { message: String },
}

#[derive(Debug, thiserror::Error)]
pub enum ProtocolError {
    #[error("Execution failed: {0}")]
    ExecutionFailed(String),
    #[error("Invalid instruction: {0}")]
    InvalidInstruction(String),
}

// ========== Core Protocol Structure ==========

/// Core data structure for protocol context execution
#[derive(Debug, Clone)]
pub struct ProtocolContextCore {
    pub context_id: Uuid,
    pub session_id: Uuid,
    pub device_id: DeviceId,
    pub protocol_type: ProtocolType,
}

impl ProtocolContextCore {
    pub fn new(
        context_id: Uuid,
        session_id: Uuid,
        device_id: DeviceId,
        protocol_type: ProtocolType,
    ) -> Self {
        Self {
            context_id,
            session_id,
            device_id,
            protocol_type,
        }
    }

    #[allow(clippy::disallowed_methods)]
    pub async fn execute(
        &mut self,
        instruction: Instruction,
    ) -> std::result::Result<InstructionResult, ProtocolError> {
        // Placeholder implementation - this will be properly implemented
        // when the session types are integrated with the actual execution runtime
        match instruction {
            Instruction::WriteToLedger(_event) => Ok(InstructionResult::EventWritten {
                event_id: Uuid::new_v4(),
            }),
            Instruction::AwaitEvent { .. } => Ok(InstructionResult::Error {
                message: "Not implemented".to_string(),
            }),
            Instruction::AwaitThreshold { .. } => Ok(InstructionResult::ThresholdMet { count: 1 }),
            Instruction::RunSubProtocol { .. } => Ok(InstructionResult::SubProtocolComplete {
                result: "Success".to_string(),
            }),
        }
    }
}

// ========== Error Type ==========

#[derive(Debug, thiserror::Error)]
pub enum ContextSessionError {
    #[error("Protocol error: {0}")]
    ProtocolError(String),
    #[error("Invalid instruction for current state")]
    InvalidInstruction,
    #[error("Context execution failed: {0}")]
    ExecutionFailed(String),
    #[error("Timeout occurred")]
    Timeout,
}

impl From<ProtocolError> for ContextSessionError {
    fn from(err: ProtocolError) -> Self {
        ContextSessionError::ProtocolError(err.to_string())
    }
}

// ========== Protocol Definition using Macros ==========

// TODO: Define protocol manually to avoid orphan rule violations
// The define_protocol! macro internally uses impl_session_protocol! which tries to
// implement external traits for external types, violating Rust's orphan rules.

// Define session states manually for now
define_session_states! {
    ContextInitialized,
    ExecutingInstructions,
    AwaitingCondition,
    WritingToLedger,
    ExecutingSubProtocol,
    ExecutionComplete @ final,
    ExecutionFailed @ final,
}

// Define union type manually (was generated by define_protocol! macro)
#[derive(Debug, Clone)]
pub enum ContextSessionState {
    ContextInitialized(SessionTypedProtocol<ProtocolContextCore, ContextInitialized>),
    ExecutingInstructions(SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>),
    AwaitingCondition(SessionTypedProtocol<ProtocolContextCore, AwaitingCondition>),
    WritingToLedger(SessionTypedProtocol<ProtocolContextCore, WritingToLedger>),
    ExecutingSubProtocol(SessionTypedProtocol<ProtocolContextCore, ExecutingSubProtocol>),
    ExecutionComplete(SessionTypedProtocol<ProtocolContextCore, ExecutionComplete>),
    ExecutionFailed(SessionTypedProtocol<ProtocolContextCore, ExecutionFailed>),
}

// Union state type for ContextSessionState
#[derive(Debug, Clone)]
pub struct ContextUnionState;

impl SessionState for ContextUnionState {
    const NAME: &'static str = "ContextUnion";
    const IS_FINAL: bool = false;
    const CAN_TERMINATE: bool = false;
}

impl SessionProtocol for ContextSessionState {
    fn session_id(&self) -> Uuid {
        match self {
            ContextSessionState::ContextInitialized(p) => p.core().session_id,
            ContextSessionState::ExecutingInstructions(p) => p.core().session_id,
            ContextSessionState::AwaitingCondition(p) => p.core().session_id,
            ContextSessionState::WritingToLedger(p) => p.core().session_id,
            ContextSessionState::ExecutingSubProtocol(p) => p.core().session_id,
            ContextSessionState::ExecutionComplete(p) => p.core().session_id,
            ContextSessionState::ExecutionFailed(p) => p.core().session_id,
        }
    }

    fn state_name(&self) -> &'static str {
        match self {
            ContextSessionState::ContextInitialized(_) => ContextInitialized::NAME,
            ContextSessionState::ExecutingInstructions(_) => ExecutingInstructions::NAME,
            ContextSessionState::AwaitingCondition(_) => AwaitingCondition::NAME,
            ContextSessionState::WritingToLedger(_) => WritingToLedger::NAME,
            ContextSessionState::ExecutingSubProtocol(_) => ExecutingSubProtocol::NAME,
            ContextSessionState::ExecutionComplete(_) => ExecutionComplete::NAME,
            ContextSessionState::ExecutionFailed(_) => ExecutionFailed::NAME,
        }
    }

    fn can_terminate(&self) -> bool {
        match self {
            ContextSessionState::ContextInitialized(_) => ContextInitialized::CAN_TERMINATE,
            ContextSessionState::ExecutingInstructions(_) => ExecutingInstructions::CAN_TERMINATE,
            ContextSessionState::AwaitingCondition(_) => AwaitingCondition::CAN_TERMINATE,
            ContextSessionState::WritingToLedger(_) => WritingToLedger::CAN_TERMINATE,
            ContextSessionState::ExecutingSubProtocol(_) => ExecutingSubProtocol::CAN_TERMINATE,
            ContextSessionState::ExecutionComplete(_) => ExecutionComplete::CAN_TERMINATE,
            ContextSessionState::ExecutionFailed(_) => ExecutionFailed::CAN_TERMINATE,
        }
    }

    fn protocol_id(&self) -> Uuid {
        match self {
            ContextSessionState::ContextInitialized(p) => p.core().context_id,
            ContextSessionState::ExecutingInstructions(p) => p.core().context_id,
            ContextSessionState::AwaitingCondition(p) => p.core().context_id,
            ContextSessionState::WritingToLedger(p) => p.core().context_id,
            ContextSessionState::ExecutingSubProtocol(p) => p.core().context_id,
            ContextSessionState::ExecutionComplete(p) => p.core().context_id,
            ContextSessionState::ExecutionFailed(p) => p.core().context_id,
        }
    }

    fn device_id(&self) -> Uuid {
        match self {
            ContextSessionState::ContextInitialized(p) => p.core().device_id.0,
            ContextSessionState::ExecutingInstructions(p) => p.core().device_id.0,
            ContextSessionState::AwaitingCondition(p) => p.core().device_id.0,
            ContextSessionState::WritingToLedger(p) => p.core().device_id.0,
            ContextSessionState::ExecutingSubProtocol(p) => p.core().device_id.0,
            ContextSessionState::ExecutionComplete(p) => p.core().device_id.0,
            ContextSessionState::ExecutionFailed(p) => p.core().device_id.0,
        }
    }

    fn is_final(&self) -> bool {
        matches!(
            self,
            ContextSessionState::ExecutionComplete(_) | ContextSessionState::ExecutionFailed(_)
        )
    }
}

// ========== Protocol Type Alias ==========

/// Session-typed protocol context wrapper
pub type ContextProtocol<S> = SessionTypedProtocol<ProtocolContextCore, S>;

// ========== Protocol Methods ==========

/// Trait for basic protocol context operations
pub trait ProtocolContextOperations {
    /// Get reference to the protocol core
    fn core(&self) -> &ProtocolContextCore;
    /// Get the context ID
    fn context_id(&self) -> Uuid;
    /// Get the protocol type
    fn protocol_type(&self) -> ProtocolType;
    /// Get the protocol ID (alias for context_id for compatibility)
    fn context_protocol_id(&self) -> Uuid;
    /// Get the device ID from the context
    fn context_device_id(&self) -> DeviceId;
    /// Check if the protocol can terminate (final states only)
    fn context_can_terminate(&self) -> bool;
}

/// Implementation for all protocol context states
impl<S: SessionState> ProtocolContextOperations for SessionTypedProtocol<ProtocolContextCore, S> {
    fn core(&self) -> &ProtocolContextCore {
        &self.inner
    }

    fn context_id(&self) -> Uuid {
        self.core().context_id
    }

    fn protocol_type(&self) -> ProtocolType {
        self.core().protocol_type
    }

    fn context_protocol_id(&self) -> Uuid {
        self.context_id()
    }

    fn context_device_id(&self) -> DeviceId {
        self.core().device_id
    }

    fn context_can_terminate(&self) -> bool {
        S::IS_FINAL
    }
}

// ========== Runtime Witnesses for Context Operations ==========

/// Witness that sufficient events have been collected for threshold operations
#[derive(Debug, Clone)]
pub struct ThresholdEventsMet {
    pub collected_count: usize,
    pub required_count: usize,
    pub matching_events: Vec<Event>,
}

impl RuntimeWitness for ThresholdEventsMet {
    type Evidence = (Vec<Event>, usize);
    type Config = ();

    fn verify(evidence: (Vec<Event>, usize), _config: ()) -> Option<Self> {
        let (events, required_count) = evidence;
        if events.len() >= required_count {
            Some(ThresholdEventsMet {
                collected_count: events.len(),
                required_count,
                matching_events: events,
            })
        } else {
            None
        }
    }

    fn description(&self) -> &'static str {
        "Threshold events collected"
    }
}

/// Witness that ledger write has been successful
#[derive(Debug, Clone)]
pub struct LedgerWriteComplete {
    pub event_written: bool,
    pub new_epoch: u64,
}

impl RuntimeWitness for LedgerWriteComplete {
    type Evidence = InstructionResult;
    type Config = ();

    fn verify(evidence: InstructionResult, _config: ()) -> Option<Self> {
        match evidence {
            InstructionResult::EventWritten { .. } => Some(LedgerWriteComplete {
                event_written: true,
                new_epoch: 0, // Would be extracted from actual result
            }),
            _ => None,
        }
    }

    fn description(&self) -> &'static str {
        "Ledger write completed"
    }
}

/// Witness that sub-protocol execution has completed
#[derive(Debug, Clone)]
pub struct SubProtocolComplete {
    pub protocol_result: String,
    pub success: bool,
}

impl RuntimeWitness for SubProtocolComplete {
    type Evidence = InstructionResult;
    type Config = ();

    fn verify(evidence: InstructionResult, _config: ()) -> Option<Self> {
        match evidence {
            InstructionResult::SubProtocolComplete { result } => Some(SubProtocolComplete {
                protocol_result: result,
                success: true,
            }),
            _ => None,
        }
    }

    fn description(&self) -> &'static str {
        "Sub-protocol completed"
    }
}

// ========== State Transitions ==========

/// Trait for context initialization operations
pub trait ContextInitializedOperations {
    /// Begin executing instructions
    fn begin_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>;
}

/// Implementation for ContextInitialized state
impl ContextInitializedOperations
    for SessionTypedProtocol<ProtocolContextCore, ContextInitialized>
{
    fn begin_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions> {
        SessionTypedProtocol::transition_to(self)
    }
}

/// Trait for executing instructions operations
pub trait ExecutingInstructionsOperations {
    /// Transition to awaiting condition state
    fn await_condition(self) -> SessionTypedProtocol<ProtocolContextCore, AwaitingCondition>;
    /// Transition to writing to ledger state
    fn write_to_ledger(self) -> SessionTypedProtocol<ProtocolContextCore, WritingToLedger>;
    /// Transition to executing sub-protocol state
    fn execute_sub_protocol(
        self,
    ) -> SessionTypedProtocol<ProtocolContextCore, ExecutingSubProtocol>;
    /// Complete execution successfully
    fn complete_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutionComplete>;
}

/// Implementation for ExecutingInstructions state
impl ExecutingInstructionsOperations
    for SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>
{
    fn await_condition(self) -> SessionTypedProtocol<ProtocolContextCore, AwaitingCondition> {
        SessionTypedProtocol::transition_to(self)
    }

    fn write_to_ledger(self) -> SessionTypedProtocol<ProtocolContextCore, WritingToLedger> {
        SessionTypedProtocol::transition_to(self)
    }

    fn execute_sub_protocol(
        self,
    ) -> SessionTypedProtocol<ProtocolContextCore, ExecutingSubProtocol> {
        SessionTypedProtocol::transition_to(self)
    }

    fn complete_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutionComplete> {
        SessionTypedProtocol::transition_to(self)
    }
}

// BEGIN DEPRECATED: Orphan rule violation implementations
/*
/*
/// Transition from AwaitingCondition back to ExecutingInstructions (requires ThresholdEventsMet witness for threshold operations)
impl WitnessedTransition<AwaitingCondition, ExecutingInstructions>
    for SessionTypedProtocol<ProtocolContextCore, AwaitingCondition>
{
    type Witness = ThresholdEventsMet;
    type Target = SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>;

    /// Resume execution after threshold condition is met
    fn transition_with_witness(self, _witness: Self::Witness) -> Self::Target {
        SessionTypedProtocol::transition_to(self)
    }
}
*/

/// Trait for awaiting condition operations
pub trait AwaitingConditionOperations {
    /// Resume execution after simple condition is met
    fn resume_execution(
        self,
    ) -> SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>;
}

/// Implementation for AwaitingCondition state
impl AwaitingConditionOperations for SessionTypedProtocol<ProtocolContextCore, AwaitingCondition> {
    fn resume_execution(
        self,
    ) -> SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions> {
        SessionTypedProtocol::transition_to(self)
    }
}

/*
/// Transition from WritingToLedger back to ExecutingInstructions (requires LedgerWriteComplete witness)
impl WitnessedTransition<WritingToLedger, ExecutingInstructions>
    for SessionTypedProtocol<ProtocolContextCore, WritingToLedger>
{
    type Witness = LedgerWriteComplete;
    type Target = SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>;

    /// Resume execution after ledger write is complete
    fn transition_with_witness(self, _witness: Self::Witness) -> Self::Target {
        SessionTypedProtocol::transition_to(self)
    }
}
*/

/*
/// Transition from ExecutingSubProtocol back to ExecutingInstructions (requires SubProtocolComplete witness)
impl WitnessedTransition<ExecutingSubProtocol, ExecutingInstructions>
    for SessionTypedProtocol<ProtocolContextCore, ExecutingSubProtocol>
{
    type Witness = SubProtocolComplete;
    type Target = SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>;

    /// Resume execution after sub-protocol completes
    fn transition_with_witness(self, _witness: Self::Witness) -> Self::Target {
        SessionTypedProtocol::transition_to(self)
    }
}
*/
// END DEPRECATED: These implementations violate orphan rules
*/

/// Trait for execution failure operations (available on any state)
pub trait ExecutionFailureOperations {
    /// Fail the execution (can be called from any state)
    fn fail_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutionFailed>;
}

/// Implementation for all protocol context states
impl<S: SessionState> ExecutionFailureOperations for SessionTypedProtocol<ProtocolContextCore, S> {
    fn fail_execution(self) -> SessionTypedProtocol<ProtocolContextCore, ExecutionFailed> {
        SessionTypedProtocol::transition_to(self)
    }
}

// ========== Context-Specific Operations ==========

/// Trait for advanced instruction execution operations
pub trait AdvancedExecutingInstructionsOperations {
    /// Execute an instruction that doesn't require state transition tracking
    fn execute_simple_instruction(
        &mut self,
        instruction: Instruction,
    ) -> impl std::future::Future<Output = std::result::Result<InstructionResult, ContextSessionError>>
           + Send;
    /// Check if the next instruction requires a state transition
    fn requires_state_transition(&self, instruction: &Instruction) -> bool;
}

/// Implementation for ExecutingInstructions state
impl AdvancedExecutingInstructionsOperations
    for SessionTypedProtocol<ProtocolContextCore, ExecutingInstructions>
{
    async fn execute_simple_instruction(
        &mut self,
        instruction: Instruction,
    ) -> std::result::Result<InstructionResult, ContextSessionError> {
        self.inner.execute(instruction).await.map_err(Into::into)
    }

    fn requires_state_transition(&self, instruction: &Instruction) -> bool {
        matches!(
            instruction,
            Instruction::WriteToLedger(_)
                | Instruction::AwaitEvent { .. }
                | Instruction::AwaitThreshold { .. }
                | Instruction::RunSubProtocol { .. }
        )
    }
}

/// Trait for advanced awaiting condition operations
pub trait AdvancedAwaitingConditionOperations {
    /// Check if threshold condition has been met
    fn check_threshold_condition(
        &mut self,
        required_count: usize,
    ) -> impl std::future::Future<Output = Option<ThresholdEventsMet>> + Send;
}

/// Implementation for AwaitingCondition state
impl AdvancedAwaitingConditionOperations
    for SessionTypedProtocol<ProtocolContextCore, AwaitingCondition>
{
    async fn check_threshold_condition(
        &mut self,
        required_count: usize,
    ) -> Option<ThresholdEventsMet> {
        // This would check the context's pending events
        // For now, return a placeholder
        let events = vec![]; // Would get from context
        ThresholdEventsMet::verify((events, required_count), ())
    }
}

/// Trait for writing to ledger operations
pub trait WritingToLedgerOperations {
    /// Execute the ledger write and check completion
    fn execute_ledger_write(
        &mut self,
        event: aura_journal::Event,
    ) -> impl std::future::Future<
        Output = std::result::Result<LedgerWriteComplete, ContextSessionError>,
    > + Send;
}

/// Implementation for WritingToLedger state
impl WritingToLedgerOperations for SessionTypedProtocol<ProtocolContextCore, WritingToLedger> {
    async fn execute_ledger_write(
        &mut self,
        event: aura_journal::Event,
    ) -> std::result::Result<LedgerWriteComplete, ContextSessionError> {
        let result = self
            .inner
            .execute(Instruction::WriteToLedger(Box::new(event)))
            .await?;
        LedgerWriteComplete::verify(result, ()).ok_or(ContextSessionError::ExecutionFailed(
            "Ledger write failed".to_string(),
        ))
    }
}

/// Trait for executing sub-protocol operations
pub trait ExecutingSubProtocolOperations {
    /// Execute sub-protocol and check completion
    fn execute_sub_protocol_instruction(
        &mut self,
        protocol_type: ProtocolType,
        context_id: Uuid,
    ) -> impl std::future::Future<
        Output = std::result::Result<SubProtocolComplete, ContextSessionError>,
    > + Send;
}

/// Implementation for ExecutingSubProtocol state
impl ExecutingSubProtocolOperations
    for SessionTypedProtocol<ProtocolContextCore, ExecutingSubProtocol>
{
    async fn execute_sub_protocol_instruction(
        &mut self,
        protocol_type: ProtocolType,
        context_id: Uuid,
    ) -> std::result::Result<SubProtocolComplete, ContextSessionError> {
        let mut params = BTreeMap::new();
        params.insert("protocol_type".to_string(), format!("{:?}", protocol_type));
        params.insert("context_id".to_string(), context_id.to_string());
        let instruction = Instruction::RunSubProtocol {
            protocol_type: format!("{:?}", protocol_type),
            parameters: params,
        };
        let result = self.inner.execute(instruction).await?;
        SubProtocolComplete::verify(result, ()).ok_or(ContextSessionError::ExecutionFailed(
            "Sub-protocol execution failed".to_string(),
        ))
    }
}

/// Trait for execution complete operations
pub trait ExecutionCompleteOperations {
    /// Get the final execution result
    fn get_execution_result(&self) -> Option<String>;
}

/// Trait for execution failed operations
pub trait ExecutionFailedOperations {
    /// Get the failure reason
    fn get_failure_reason(&self) -> Option<String>;
}

/// Implementation for ExecutionComplete state
impl ExecutionCompleteOperations for SessionTypedProtocol<ProtocolContextCore, ExecutionComplete> {
    fn get_execution_result(&self) -> Option<String> {
        Some("Execution completed successfully".to_string())
    }
}

/// Implementation for ExecutionFailed state
impl ExecutionFailedOperations for SessionTypedProtocol<ProtocolContextCore, ExecutionFailed> {
    fn get_failure_reason(&self) -> Option<String> {
        Some("Execution failed".to_string())
    }
}

// ========== Factory Functions ==========

/// Create a new session-typed protocol context
pub fn new_session_typed_context(
    context_id: Uuid,
    session_id: Uuid,
    device_id: DeviceId,
    protocol_type: ProtocolType,
) -> SessionTypedProtocol<ProtocolContextCore, ContextInitialized> {
    let core = ProtocolContextCore::new(context_id, session_id, device_id, protocol_type);
    SessionTypedProtocol::new(core)
}

/// Rehydrate a protocol context session from execution state
pub fn rehydrate_context_session(
    context_id: Uuid,
    session_id: Uuid,
    device_id: DeviceId,
    protocol_type: ProtocolType,
    last_instruction: Option<&Instruction>,
) -> ContextSessionState {
    let core = ProtocolContextCore::new(context_id, session_id, device_id, protocol_type);

    match last_instruction {
        Some(Instruction::WriteToLedger(_)) => {
            ContextSessionState::WritingToLedger(SessionTypedProtocol::new(core))
        }
        Some(Instruction::AwaitEvent { .. }) | Some(Instruction::AwaitThreshold { .. }) => {
            ContextSessionState::AwaitingCondition(SessionTypedProtocol::new(core))
        }
        Some(Instruction::RunSubProtocol { .. }) => {
            ContextSessionState::ExecutingSubProtocol(SessionTypedProtocol::new(core))
        }
        _ => ContextSessionState::ExecutingInstructions(SessionTypedProtocol::new(core)),
    }
}

// SessionProtocol implementation is provided by ContextSessionState union type

#[allow(clippy::disallowed_methods, clippy::expect_used, clippy::unwrap_used)]
#[cfg(test)]
mod tests {
    use super::*;
    use aura_crypto::Effects;
    use aura_types::{AccountId, DeviceId, DeviceIdExt};

    #[allow(clippy::disallowed_methods)]
    #[test]
    fn test_context_state_transitions() {
        let effects = Effects::test();
        let context_id = effects.gen_uuid();
        let session_id = effects.gen_uuid();
        let device_id = DeviceId::new_with_effects(&effects);
        let protocol_type = ProtocolType::Dkd;

        // Test basic state transitions using typestate pattern
        let session_context =
            new_session_typed_context(context_id, session_id, device_id, protocol_type);

        // Verify we can access the inner core through the typed protocol
        assert_eq!(session_context.core().context_id, context_id);
        assert_eq!(session_context.core().session_id, session_id);

        // Transition to ExecutingInstructions - this compiles, proving typestate works
        let executing_context = session_context.begin_execution();
        assert_eq!(executing_context.core().context_id, context_id);

        // Can fail from any state
        let failed_context = executing_context.fail_execution();
        assert_eq!(failed_context.core().context_id, context_id);
    }

    #[allow(clippy::disallowed_methods)]
    #[test]
    fn test_context_witness_verification() {
        // Test ThresholdEventsMet witness
        let events = vec![];
        let witness = ThresholdEventsMet::verify((events, 2), ());
        assert!(witness.is_none()); // Not enough events

        // Test with sufficient events
        let events = vec![];
        let witness = ThresholdEventsMet::verify((events, 0), ());
        assert!(witness.is_some());
    }

    #[allow(clippy::disallowed_methods)]
    #[test]
    fn test_context_rehydration() {
        let effects = Effects::test();
        let context_id = effects.gen_uuid();
        let session_id = effects.gen_uuid();
        let device_id = DeviceId::new_with_effects(&effects);
        let protocol_type = ProtocolType::Dkd;

        // Test rehydration without last instruction - returns ExecutingInstructions state
        let state =
            rehydrate_context_session(context_id, session_id, device_id, protocol_type, None);

        // Verify the rehydrated state is ExecutingInstructions
        assert!(matches!(
            state,
            ContextSessionState::ExecutingInstructions(_)
        ));
    }

    #[allow(clippy::disallowed_methods)]
    #[test]
    fn test_context_specific_operations() {
        let effects = Effects::test();
        let context_id = effects.gen_uuid();
        let session_id = effects.gen_uuid();
        let device_id = DeviceId::new_with_effects(&effects);
        let protocol_type = ProtocolType::Dkd;

        let session_context =
            new_session_typed_context(context_id, session_id, device_id, protocol_type);
        let executing_context = session_context.begin_execution();

        // Create a test event for instruction testing
        let dummy_signature = ed25519_dalek::Signature::from_bytes(&[0u8; 64]);
        let test_event = aura_journal::Event::new(
            AccountId(effects.gen_uuid()),
            1,
            None,
            0,
            aura_journal::EventType::EpochTick(aura_journal::events::EpochTickEvent {
                new_epoch: 1,
                evidence_hash: [0u8; 32],
            }),
            aura_journal::EventAuthorization::DeviceCertificate {
                device_id,
                signature: dummy_signature,
            },
            &effects,
        )
        .unwrap();

        // Test instruction type checking
        let write_instruction = Instruction::WriteToLedger(Box::new(test_event));
        assert!(executing_context.requires_state_transition(&write_instruction));

        // Transition to different states - typestate ensures compile-time safety
        let awaiting_context = executing_context.await_condition();
        assert_eq!(awaiting_context.core().context_id, context_id);
    }

    #[allow(clippy::disallowed_methods)]
    #[test]
    fn test_union_type_functionality() {
        let effects = Effects::test();
        let context_id = effects.gen_uuid();
        let session_id = effects.gen_uuid();
        let device_id = DeviceId::new_with_effects(&effects);
        let protocol_type = ProtocolType::Dkd;

        let state =
            rehydrate_context_session(context_id, session_id, device_id, protocol_type, None);

        // Test that union type works - verify it's the right variant
        assert!(matches!(
            state,
            ContextSessionState::ExecutingInstructions(_)
        ));
    }
}
