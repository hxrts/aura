#![allow(clippy::type_complexity)]

//! Aura Choreography Proc Macros
//!
//! This crate provides the `choreography!` macro that enhances
//! rumpsteak-aura choreographies with Aura-specific capability guards,
//! flow cost management, and journal facts integration using the native
//! rumpsteak-aura 0.5.0 extension system.
//!
//! The implementation uses rumpsteak-aura's native extension API to provide
//! first-class support for Aura annotations without any custom parsing.
//!
//! # Example
//!
//! ```ignore
//! use aura_macros::choreography;
//!
//! choreography! {
//!     #[namespace = "threshold_ceremony"]
//!     protocol ThresholdCeremony {
//!         roles: Coordinator, Signers;
//!
//!         Coordinator[guard_capability = "coordinate_signing",
//!                    flow_cost = 200,
//!                    journal_facts = "threshold_initiated"]
//!         -> Signers: SignRequest;
//!
//!         Signers[guard_capability = "participate_signing",
//!                flow_cost = 150]
//!         -> Coordinator: NonceCommit;
//!     }
//! }
//! ```

use proc_macro::TokenStream;

mod rumpsteak_macro;
mod test_macro;


/// Aura choreography macro that enhances rumpsteak-aura with Aura-specific capabilities
///
/// This is Aura's primary choreography macro that extends rumpsteak-aura's choreographic
/// programming with capability guards, flow cost management, and journal facts using the
/// native rumpsteak-aura 0.5.0 extension system.
///
/// # Supported Annotations
///
/// - `guard_capability = "capability_name"` - Required capability for the operation
/// - `flow_cost = <number>` - Flow cost for the communication
/// - `journal_facts = "description"` - Journal facts to add
/// - `journal_merge = true` - Enable journal merge operation
///
/// # Generated Code
///
/// The macro generates:
/// - Standard rumpsteak-aura session types and role definitions
/// - Extension effects for Aura-specific functionality integrated into the protocol
/// - Capability validation, flow cost charging, and journal fact recording
/// - Properly projected local types with extension support
///
/// # Example
///
/// ```ignore
/// use aura_macros::choreography;
///
/// choreography! {
///     #[namespace = "threshold_ceremony"]
///     protocol ThresholdCeremony {
///         roles: Coordinator, Signers;
///
///         Coordinator[guard_capability = "coordinate_signing",
///                    flow_cost = 200,
///                    journal_facts = "threshold_initiated"]
///         -> Signers: SignRequest;
///     }
/// }
/// ```
#[proc_macro]
pub fn choreography(input: TokenStream) -> TokenStream {
    match rumpsteak_macro::choreography_impl(input) {
        Ok(output) => output,
        Err(err) => err.to_compile_error().into(),
    }
}

// Note: proc-macro crates cannot export types, only macros
// The effect system types are generated by the choreography! macro

#[cfg(test)]
mod tests {
    #[test]
    fn test_extension_registry_creation() {
        // Test that we can create the extension registry
        let _registry = crate::rumpsteak_macro::create_aura_extension_registry();
        
        // Extension registry is created successfully
        // Note: The can_handle method requires actual parser registration
        // which happens during choreography parsing, not at creation time
    }

    // Note: Proc macro tests cannot be run in unit tests because they require
    // a compile-time context. The macro functionality is verified through
    // integration tests and actual usage in the codebase.
}

/// Async-native test attribute macro for Aura
///
/// This macro automatically sets up and tears down the effect system for each test,
/// providing a clean testing environment with proper async support.
///
/// # Basic Usage
///
/// ```ignore
/// #[aura_test]
/// async fn test_something() -> AuraResult<()> {
///     // Effect system is automatically initialized
///     // Test your code here
///     Ok(())
/// }
/// ```
///
/// # Attributes
///
/// - `no_init`: Skip automatic effect system initialization
/// - `no_scope`: Don't use a scoped container
/// - `capture`: Enable effect capture for assertions
/// - `timeout = N`: Set test timeout in seconds
/// - `no_deterministic_time`: Use real time instead of frozen time
///
/// # Examples
///
/// ```ignore
/// #[aura_test(timeout = 30, capture)]
/// async fn test_with_capture() -> AuraResult<()> {
///     // Test with 30 second timeout and effect capture enabled
///     Ok(())
/// }
///
/// #[aura_test(no_init)]
/// async fn test_manual_init() -> AuraResult<()> {
///     // Manually initialize effect system
///     let effects = AuraEffectSystemBuilder::new()
///         .with_device_id(DeviceId::new())
///         .build_sync()?;
///     Ok(())
/// }
/// ```
#[proc_macro_attribute]
pub fn aura_test(attr: TokenStream, item: TokenStream) -> TokenStream {
    match test_macro::aura_test_impl(attr, item) {
        Ok(output) => output,
        Err(err) => err.to_compile_error().into(),
    }
}
