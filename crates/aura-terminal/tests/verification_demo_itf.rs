#![allow(
    clippy::expect_used,
    clippy::unwrap_used,
    clippy::clone_on_copy,
    dead_code
)]
//! CLI Recovery Demo ITF Trace Replay Tests
//!
//! These tests validate the guardian relationship invariants from the Quint spec:
//! - Guardians must be contacts first
//! - After guardian acceptance, both `guardians` and `guardianFor` are updated
//! - `isContactGuardian` returns true for accepted guardian relationships
//!
//! The test parses ITF traces generated by `cli_recovery_demo.qnt` and validates
//! that the state transitions maintain all invariants.

use serde::Deserialize;
use std::collections::{HashMap, HashSet};
use std::path::Path;

/// ITF trace structure matching Quint output
#[derive(Debug, Clone, Deserialize)]
struct ITFTrace {
    #[serde(rename = "#meta")]
    meta: ITFMeta,
    vars: Vec<String>,
    states: Vec<ITFState>,
}

/// ITF trace metadata
#[derive(Debug, Clone, Deserialize)]
struct ITFMeta {
    format: String,
    #[allow(dead_code)]
    source: String,
    status: String,
}

/// Single state in ITF trace
#[derive(Debug, Clone, Deserialize)]
struct ITFState {
    #[serde(rename = "#meta")]
    meta: ITFStateMeta,
    #[serde(flatten)]
    variables: HashMap<String, serde_json::Value>,
}

/// State metadata
#[derive(Debug, Clone, Deserialize)]
struct ITFStateMeta {
    index: usize,
}

/// Agent state extracted from ITF
#[derive(Debug, Clone)]
struct AgentState {
    authority_id: String,
    has_account: bool,
    contacts: HashSet<String>,
    guardians: HashSet<String>,
    guardian_for: HashSet<String>,
}

/// Parse a set from ITF format
fn parse_set(value: &serde_json::Value) -> HashSet<String> {
    let mut result = HashSet::new();
    if let Some(obj) = value.as_object() {
        if let Some(arr) = obj.get("#set").and_then(|v| v.as_array()) {
            for item in arr {
                if let Some(s) = item.as_str() {
                    result.insert(s.to_string());
                }
            }
        }
    }
    result
}

/// Parse agents map from ITF format
fn parse_agents(agents_value: &serde_json::Value) -> HashMap<String, AgentState> {
    let mut result = HashMap::new();

    if let Some(obj) = agents_value.as_object() {
        if let Some(map_arr) = obj.get("#map").and_then(|v| v.as_array()) {
            for entry in map_arr {
                if let Some(arr) = entry.as_array() {
                    if arr.len() == 2 {
                        let agent_id = arr[0].as_str().unwrap_or_default().to_string();
                        let state = &arr[1];

                        let authority_id = state
                            .get("authorityId")
                            .and_then(|v| v.as_str())
                            .unwrap_or_default()
                            .to_string();

                        let has_account = state
                            .get("hasAccount")
                            .and_then(|v| v.as_bool())
                            .unwrap_or(false);

                        let contacts = state.get("contacts").map(parse_set).unwrap_or_default();

                        let guardians = state.get("guardians").map(parse_set).unwrap_or_default();

                        let guardian_for =
                            state.get("guardianFor").map(parse_set).unwrap_or_default();

                        result.insert(
                            agent_id,
                            AgentState {
                                authority_id,
                                has_account,
                                contacts,
                                guardians,
                                guardian_for,
                            },
                        );
                    }
                }
            }
        }
    }

    result
}

/// Check if a contact is also a guardian (isContactGuardian from Quint spec)
fn is_contact_guardian(agent: &AgentState, contact_id: &str) -> bool {
    agent.contacts.contains(contact_id) && agent.guardians.contains(contact_id)
}

/// Validate that all guardians are contacts (invariant from Quint spec)
fn guardians_are_contacts(agents: &HashMap<String, AgentState>) -> bool {
    for agent in agents.values() {
        for guardian in &agent.guardians {
            if !agent.contacts.contains(guardian) {
                return false;
            }
        }
    }
    true
}

/// Validate guardian bidirectionality (invariant from Quint spec)
fn guardian_bidirectionality(agents: &HashMap<String, AgentState>) -> bool {
    for (agent_id, agent) in agents {
        for guardian_id in &agent.guardians {
            if let Some(guardian) = agents.get(guardian_id) {
                if !guardian.guardian_for.contains(agent_id) {
                    return false;
                }
            }
        }
    }
    true
}

/// Load and parse an ITF trace file
fn load_trace(path: impl AsRef<Path>) -> Result<ITFTrace, String> {
    let content = std::fs::read_to_string(path.as_ref())
        .map_err(|e| format!("Failed to read ITF file: {e}"))?;
    let trace: ITFTrace =
        serde_json::from_str(&content).map_err(|e| format!("Failed to parse ITF JSON: {e}"))?;
    Ok(trace)
}

/// Test that validates CLI recovery demo invariants from ITF trace
#[test]
fn test_cli_recovery_demo_invariants() {
    let trace_path = "../../verification/traces/cli_recovery_demo.itf.json";

    // Skip if trace file doesn't exist
    if !std::path::Path::new(trace_path).exists() {
        eprintln!(
            "Skipping: trace file not found at {trace_path}. Run: nix develop -c quint run --out-itf=verification/traces/cli_recovery_demo.itf.json --max-samples=1 --init=init --step=guardianRequestFlowTest verification/quint/cli_recovery_demo.qnt"
        );
        return;
    }

    let trace = load_trace(trace_path).expect("Failed to load trace");

    assert_eq!(trace.meta.format, "ITF");
    assert_eq!(trace.meta.status, "ok");

    println!("Validating {} states from ITF trace...", trace.states.len());

    let mut guardian_relationships_found = 0;
    let mut max_guardians_per_agent = 0;

    for itf_state in &trace.states {
        let agents_value = itf_state
            .variables
            .get("agents")
            .expect("Missing agents variable");

        let agents = parse_agents(agents_value);

        // Validate invariants at each state
        assert!(
            guardians_are_contacts(&agents),
            "State {}: guardians must be contacts",
            itf_state.meta.index
        );

        assert!(
            guardian_bidirectionality(&agents),
            "State {}: guardian relationship must be bidirectional",
            itf_state.meta.index
        );

        // Track guardian relationships
        for (agent_id, agent) in &agents {
            let num_guardians = agent.guardians.len();
            if num_guardians > max_guardians_per_agent {
                max_guardians_per_agent = num_guardians;
            }

            // Validate isContactGuardian for all guardians
            for guardian_id in &agent.guardians {
                assert!(
                    is_contact_guardian(agent, guardian_id),
                    "State {}: {} should be contact-guardian of {}",
                    itf_state.meta.index,
                    guardian_id,
                    agent_id
                );
                guardian_relationships_found += 1;
            }
        }
    }

    println!("Validation complete:");
    println!("  States validated: {}", trace.states.len());
    println!("  Guardian relationships validated: {guardian_relationships_found}");
    println!("  Max guardians per agent: {max_guardians_per_agent}");

    // Ensure we actually found guardian relationships
    assert!(
        guardian_relationships_found > 0,
        "Expected to find guardian relationships in trace"
    );
}

/// Test that validates the final state has correct guardian setup
#[test]
fn test_final_guardian_state() {
    let trace_path = "../../verification/traces/cli_recovery_demo.itf.json";

    // Skip if trace file doesn't exist
    if !std::path::Path::new(trace_path).exists() {
        eprintln!("Skipping: trace file not found");
        return;
    }

    let trace = load_trace(trace_path).expect("Failed to load trace");

    // Get the last state
    let final_state = trace.states.last().expect("Trace should have states");
    let agents_value = final_state
        .variables
        .get("agents")
        .expect("Missing agents variable");
    let agents = parse_agents(agents_value);

    // The demo flow should result in bob having alice as a guardian
    // (based on guardianRequestFlowTest)
    if let Some(bob) = agents.get("bob") {
        println!("Bob's final state:");
        println!("  Contacts: {:?}", bob.contacts);
        println!("  Guardians: {:?}", bob.guardians);

        // If Alice is a guardian, she must also be a contact
        if bob.guardians.contains("alice") {
            assert!(
                bob.contacts.contains("alice"),
                "Alice is a guardian but not a contact - invariant violation!"
            );
            assert!(
                is_contact_guardian(bob, "alice"),
                "isContactGuardian(bob, alice) should be true"
            );
            println!("  ✓ Alice is both contact AND guardian (is_guardian=true)");
        }
    }

    // Validate Alice's guardianFor
    if let Some(alice) = agents.get("alice") {
        println!("Alice's final state:");
        println!("  Guardian for: {:?}", alice.guardian_for);

        if alice.guardian_for.contains("bob") {
            println!("  ✓ Alice is guardian FOR bob (bidirectional relationship)");
        }
    }
}

/// Test full demo flow trace validation
#[test]
fn test_full_demo_flow_trace() {
    // Generate fresh trace from fullCliRecoveryDemoTest
    // Call quint directly (CI installs via npm, local dev uses nix)
    let output = std::process::Command::new("quint")
        .args([
            "run",
            "--out-itf=verification/traces/full_demo.itf.json",
            "--max-samples=1",
            "--init=init",
            "--step=fullCliRecoveryDemoTest",
            "verification/quint/cli_recovery_demo.qnt",
        ])
        .current_dir("../../")
        .output();

    let output = match output {
        Ok(o) => o,
        Err(e) => {
            eprintln!("Skipping: Failed to run Quint: {e}");
            return;
        }
    };

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        eprintln!("Quint run failed: {stderr}");
        // Don't fail the test if quint isn't available
        if stderr.contains("command not found") || stderr.contains("No such file") {
            eprintln!("Skipping: Quint not available in test environment");
            return;
        }
        panic!("Quint run failed: {stderr}");
    }

    let trace_path = "../../verification/traces/full_demo.itf.json";
    let trace = load_trace(trace_path).expect("Failed to load trace");

    println!(
        "Full demo trace: {} states, {} variables",
        trace.states.len(),
        trace.vars.len()
    );

    // Find states where bob has 2 guardians
    let mut found_two_guardians = false;
    for itf_state in &trace.states {
        let agents_value = itf_state
            .variables
            .get("agents")
            .expect("Missing agents variable");
        let agents = parse_agents(agents_value);

        if let Some(bob) = agents.get("bob") {
            if bob.guardians.len() == 2 {
                found_two_guardians = true;
                println!(
                    "State {}: Bob has 2 guardians: {:?}",
                    itf_state.meta.index, bob.guardians
                );

                // Validate both are contact-guardians
                for guardian_id in &bob.guardians {
                    assert!(
                        is_contact_guardian(bob, guardian_id),
                        "Guardian {guardian_id} should be contact-guardian"
                    );
                }

                // Validate invariants
                assert!(guardians_are_contacts(&agents));
                assert!(guardian_bidirectionality(&agents));
            }
        }
    }

    assert!(
        found_two_guardians,
        "Full demo should result in Bob having 2 guardians"
    );

    // Clean up
    let _ = std::fs::remove_file(trace_path);
}
