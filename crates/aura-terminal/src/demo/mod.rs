//! # Demo Module
//!
//! Provides demo modes for showcasing Aura's capabilities.
//!
//! The demo architecture uses the simulator to instantiate agents (Alice, Carol)
//! that the user (Bob) interacts with through the TUI. The demo layer is thin,
//! simply providing initialization of the simulation configuration and guided flows
//! with contextual tips.
//!
//! ## Architecture
//!
//! SimulatedAgent represents a general authority that can dynamically assume
//! capabilities through the proper ceremony processes:
//!
//! - **Guardian role**: Assumed through GuardianBinding in a relational context
//! - **Recovery approval**: Granted through RecoveryGrant facts
//! - **Messaging**: Standard authority-to-authority communication
//!
//! The agent doesn't start as a "guardian" - it becomes one through the
//! interactive guardian ceremony, mirroring real Aura semantics.
//!
//! ## Submodules
//!
//! - `simulator`: The DemoSimulator coordinator that manages Alice/Carol agents
//! - `hints`: Demo mode hints and invite code generation

pub mod hints;
pub mod signal_coordinator;
pub mod simulator;

pub use hints::DemoHints;
pub use signal_coordinator::DemoSignalCoordinator;
pub use simulator::DemoSimulator;

use crate::error::TerminalResult;
use aura_core::PhysicalTimeEffects;
use aura_effects::time::PhysicalTimeHandler;
use std::collections::HashSet;
use std::sync::Arc;
use std::time::Instant;
use tokio::sync::{broadcast, mpsc, Mutex};

use aura_core::effects::{amp::AmpChannelEffects, StorageEffects};
use aura_core::hash::hash;
use aura_core::{AuthorityId, ChannelId, ContextId, DeviceId};
use aura_simulator::{ComposedSimulationEnvironment, SimulationEffectComposer};
use std::str::FromStr;

use crate::ids;
use crate::tui::effects::{AuraEvent, EffectCommand, EventFilter, EventSubscription};

/// High-level demo progression phases used by the simulator integration.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum DemoPhase {
    /// Initial device-loss experience before guardians are coordinated
    DeviceLoss,
    /// Guardians being coordinated/added for recovery
    GuardianCoordination,
}

/// Capabilities an agent can acquire through ceremonies
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AgentCapability {
    /// Can approve recovery requests for a specific account
    Guardian {
        /// The account authority this agent is guardian for
        account_authority: AuthorityId,
        /// The relational context for this guardian binding
        context_id: ContextId,
    },
    /// Can participate in messaging channels
    Messaging {
        /// Channel ID
        channel_id: String,
    },
    /// Can participate in consensus as a witness
    ConsensusWitness {
        /// The context this agent witnesses for
        context_id: ContextId,
    },
}

/// Events that flow between agents and the demo system
#[derive(Debug, Clone)]
pub enum AgentEvent {
    /// Message received from another authority
    MessageReceived {
        /// Sender of the message
        from: AuthorityId,
        /// Channel where the message was posted
        channel: String,
        /// Message body
        content: String,
    },
    /// Recovery request from an account
    RecoveryRequested {
        /// Account requesting recovery
        account: AuthorityId,
        /// Session identifier for the recovery flow
        session_id: String,
        /// Context in which recovery is scoped
        context_id: ContextId,
    },
    /// Guardian binding ceremony initiated
    GuardianCeremonyStarted {
        /// Account that will gain a guardian
        account: AuthorityId,
        /// Relational context for the guardian binding
        context_id: ContextId,
    },
    /// Phase change notification
    PhaseChanged {
        /// Updated demo phase
        new_phase: DemoPhase,
    },
}

/// Responses generated by agents
#[derive(Debug, Clone)]
pub enum AgentResponse {
    /// Send a message
    SendMessage {
        /// Channel to send to
        channel: String,
        /// Message body
        content: String,
    },
    /// Approve a recovery request
    ApproveRecovery {
        /// Recovery session identifier
        session_id: String,
        /// Account being recovered
        account: AuthorityId,
    },
    /// Accept guardian binding
    AcceptGuardianBinding {
        /// Account to guard
        account: AuthorityId,
        /// Context in which the guardian binding applies
        context_id: ContextId,
    },
}

/// Simulator-backed automated agent
///
/// Represents a general authority that can dynamically assume capabilities
/// through relational contexts and ceremonies. Does NOT start with any
/// special roles - guardianship is assumed through the binding ceremony.
pub struct SimulatedAgent {
    /// Display name (e.g., "Alice", "Carol")
    name: String,

    /// Authority ID for this agent
    authority_id: AuthorityId,

    /// Device ID for simulation
    device_id: DeviceId,

    /// Simulation environment from aura-simulator
    environment: Arc<Mutex<ComposedSimulationEnvironment>>,

    /// Agent configuration
    config: AgentConfig,

    /// Agent state
    state: AgentState,

    /// Event sender for outgoing responses
    response_tx: Option<mpsc::UnboundedSender<(AuthorityId, AgentResponse)>>,
}

/// Configuration for agent behavior
#[derive(Debug, Clone)]
pub struct AgentConfig {
    /// Simulation seed for deterministic behavior
    pub seed: u64,

    /// Response delay range (min, max) in milliseconds
    pub response_delay_ms: (u64, u64),

    /// Approval probability for recovery requests (0.0-1.0)
    pub approval_probability: f64,

    /// Message generation frequency in milliseconds
    pub message_frequency_ms: u64,

    /// Enable verbose logging
    pub verbose_logging: bool,

    /// Personality traits for message generation
    pub personality: AgentPersonality,
}

/// Personality traits that influence agent behavior
#[derive(Debug, Clone)]
pub struct AgentPersonality {
    /// How often to respond to messages (0.0-1.0)
    pub chattiness: f64,
    /// Response style keywords
    pub style: Vec<String>,
    /// Greeting phrases
    pub greetings: Vec<String>,
}

impl Default for AgentPersonality {
    fn default() -> Self {
        Self {
            chattiness: 0.3,
            style: vec!["friendly".to_string()],
            greetings: vec!["Hello!".to_string(), "Hi there!".to_string()],
        }
    }
}

impl Default for AgentConfig {
    fn default() -> Self {
        Self {
            seed: 42,
            response_delay_ms: (1000, 5000),
            approval_probability: 0.95,
            message_frequency_ms: 10000,
            verbose_logging: false,
            personality: AgentPersonality::default(),
        }
    }
}

/// Agent state tracking
#[derive(Debug, Clone, Default)]
pub struct AgentState {
    /// Capabilities acquired through ceremonies
    pub capabilities: HashSet<AgentCapability>,

    /// Whether agent is actively monitoring events
    pub monitoring: bool,

    /// Number of recovery approvals given
    pub recovery_approvals: usize,

    /// Number of messages sent
    pub messages_sent: usize,

    /// Last action timestamp
    pub last_action_time: Option<Instant>,

    /// Current demo phase awareness
    pub current_phase: Option<DemoPhase>,

    /// Pending recovery requests awaiting decision
    pub pending_recovery_requests: Vec<String>,
}

impl SimulatedAgent {
    /// Create a new simulated agent
    pub async fn new(name: String, config: AgentConfig) -> TerminalResult<Self> {
        Self::new_with_shared_transport(name, config, None).await
    }

    /// Create a new simulated agent with optional shared transport inbox
    pub async fn new_with_shared_transport(
        name: String,
        config: AgentConfig,
        shared_inbox: Option<Arc<std::sync::RwLock<Vec<aura_core::effects::TransportEnvelope>>>>,
    ) -> TerminalResult<Self> {
        // Create deterministic identifiers derived from seed and name
        let device_id = ids::device_id(&format!("demo:{}:{}:device", config.seed, name));
        let authority_id = ids::authority_id(&format!("demo:{}:{}:authority", config.seed, name));

        // Create simulation environment with optional shared transport
        let environment = if let Some(inbox) = shared_inbox {
            SimulationEffectComposer::for_simulation_async_with_shared_transport(
                device_id,
                config.seed,
                inbox,
            )
            .await?
        } else {
            SimulationEffectComposer::for_simulation_async(device_id, config.seed).await?
        };

        tracing::info!(
            "Created simulated agent: {} (device: {}, authority: {})",
            name,
            device_id,
            authority_id
        );

        Ok(Self {
            name,
            authority_id,
            device_id,
            environment: Arc::new(Mutex::new(environment)),
            config,
            state: AgentState::default(),
            response_tx: None,
        })
    }

    /// Set the response channel for outgoing events
    pub fn set_response_channel(
        &mut self,
        tx: mpsc::UnboundedSender<(AuthorityId, AgentResponse)>,
    ) {
        self.response_tx = Some(tx);
    }

    /// Get the agent's authority ID
    pub fn authority_id(&self) -> AuthorityId {
        self.authority_id
    }

    /// Get the agent's name
    pub fn name(&self) -> &str {
        &self.name
    }

    /// Start the agent's autonomous behavior
    pub async fn start(&mut self) -> TerminalResult<()> {
        self.state.monitoring = true;
        tracing::info!("Agent {} started monitoring", self.name);
        Ok(())
    }

    /// Stop the agent
    pub async fn stop(&mut self) -> TerminalResult<()> {
        self.state.monitoring = false;
        tracing::info!("Agent {} stopped", self.name);
        Ok(())
    }

    /// Check if agent has guardian capability for a specific account
    pub fn is_guardian_for(&self, account: &AuthorityId) -> bool {
        self.state.capabilities.iter().any(|cap| {
            matches!(cap, AgentCapability::Guardian { account_authority, .. } if account_authority == account)
        })
    }

    /// Add guardian capability for an account
    ///
    /// This makes the agent a guardian for the specified account,
    /// allowing them to approve recovery requests.
    pub fn add_guardian_for(&mut self, account: AuthorityId, context_id: ContextId) {
        self.state.capabilities.insert(AgentCapability::Guardian {
            account_authority: account,
            context_id,
        });
        tracing::info!(
            "Agent {} is now a guardian for account {}",
            self.name,
            account
        );
    }

    /// Check for and process incoming transport messages (guardian invitations, etc.)
    pub async fn process_transport_messages(&mut self) -> TerminalResult<Vec<AgentResponse>> {
        use aura_core::effects::TransportEffects;

        let mut responses = Vec::new();

        // Poll for incoming messages
        let env = self.environment.lock().await;
        let effects = env.effect_system();

        // Try to receive messages (non-blocking via NoMessage error)
        loop {
            match effects.receive_envelope().await {
                Ok(envelope) => {
                    // Check if this is a guardian ceremony invitation
                    if envelope.metadata.get("content-type")
                        == Some(&"application/aura-guardian-proposal".to_string())
                    {
                        tracing::info!(
                            "{} received guardian ceremony invitation from {}",
                            self.name,
                            envelope.source
                        );

                        // In demo mode, auto-accept guardian invitations
                        if let Some(ceremony_id) = envelope.metadata.get("ceremony-id") {
                            tracing::info!(
                                "{} auto-accepting guardian ceremony {}",
                                self.name,
                                ceremony_id
                            );

                            // Add guardian capability for the initiator
                            self.state.capabilities.insert(AgentCapability::Guardian {
                                account_authority: envelope.source,
                                context_id: envelope.context,
                            });

                            // Send acceptance response back through transport
                            let mut response_metadata = std::collections::HashMap::new();
                            response_metadata.insert(
                                "content-type".to_string(),
                                "application/aura-guardian-acceptance".to_string(),
                            );
                            response_metadata
                                .insert("ceremony-id".to_string(), ceremony_id.clone());
                            response_metadata
                                .insert("guardian-id".to_string(), self.authority_id.to_string());

                            let response_envelope = aura_core::effects::TransportEnvelope {
                                destination: envelope.source, // Send back to initiator (Bob)
                                source: self.authority_id,
                                context: envelope.context,
                                payload: vec![], // Empty payload for now
                                metadata: response_metadata,
                                receipt: None,
                            };

                            // Send through transport effects
                            if let Err(e) = effects.send_envelope(response_envelope).await {
                                tracing::error!(
                                    "{} failed to send acceptance response: {}",
                                    self.name,
                                    e
                                );
                            } else {
                                tracing::info!(
                                    "{} sent acceptance response for ceremony {}",
                                    self.name,
                                    ceremony_id
                                );
                            }

                            // Generate acceptance response for local processing
                            responses.push(AgentResponse::AcceptGuardianBinding {
                                account: envelope.source,
                                context_id: envelope.context,
                            });
                        }
                    }
                }
                Err(aura_core::effects::TransportError::NoMessage) => {
                    // No more messages
                    break;
                }
                Err(e) => {
                    tracing::warn!("{} error receiving transport message: {}", self.name, e);
                    break;
                }
            }
        }

        Ok(responses)
    }

    /// Process an incoming event and generate responses
    pub async fn process_event(
        &mut self,
        event: &AgentEvent,
    ) -> TerminalResult<Vec<AgentResponse>> {
        if !self.state.monitoring {
            return Ok(vec![]);
        }

        let mut responses = Vec::new();

        match event {
            AgentEvent::MessageReceived {
                from,
                channel,
                content,
            } => {
                if let Some(response) = self.handle_message(from, channel, content).await? {
                    responses.push(response);
                }
            }
            AgentEvent::RecoveryRequested {
                account,
                session_id,
                context_id,
            } => {
                if let Some(response) = self
                    .handle_recovery_request(account, session_id, context_id)
                    .await?
                {
                    responses.push(response);
                }
            }
            AgentEvent::GuardianCeremonyStarted {
                account,
                context_id,
            } => {
                if let Some(response) = self.handle_guardian_ceremony(account, context_id).await? {
                    responses.push(response);
                }
            }
            AgentEvent::PhaseChanged { new_phase } => {
                self.state.current_phase = Some(new_phase.clone());
                responses.extend(self.handle_phase_change(new_phase).await?);
            }
        }

        // Send responses through channel if available
        if let Some(tx) = &self.response_tx {
            for response in &responses {
                let _ = tx.send((self.authority_id, response.clone()));
            }
        }

        Ok(responses)
    }

    /// Handle incoming message and potentially respond
    async fn handle_message(
        &mut self,
        from: &AuthorityId,
        channel: &str,
        content: &str,
    ) -> TerminalResult<Option<AgentResponse>> {
        tracing::debug!(
            "Agent {} received message from {} in {}: {}",
            self.name,
            from,
            channel,
            content
        );

        // Simulate thinking delay
        let delay = self.calculate_response_delay();
        PhysicalTimeHandler::new().sleep_ms(delay / 2).await.ok();

        // Generate contextual response based on content
        let response = self.generate_contextual_response(content).await?;

        if let Some(response_content) = response {
            self.state.messages_sent += 1;
            Ok(Some(AgentResponse::SendMessage {
                channel: channel.to_string(),
                content: response_content,
            }))
        } else {
            Ok(None)
        }
    }

    /// Handle recovery request
    async fn handle_recovery_request(
        &mut self,
        account: &AuthorityId,
        session_id: &str,
        _context_id: &ContextId,
    ) -> TerminalResult<Option<AgentResponse>> {
        // Check if we're a guardian for this account
        if !self.is_guardian_for(account) {
            tracing::debug!(
                "Agent {} received recovery request but is not guardian for {}",
                self.name,
                account
            );
            return Ok(None);
        }

        tracing::info!(
            "Agent {} (guardian) handling recovery request for {} (session: {})",
            self.name,
            account,
            session_id
        );

        // Simulate deliberation delay
        let delay = self.calculate_response_delay();
        PhysicalTimeHandler::new().sleep_ms(delay).await.ok();

        // Determine approval based on probability
        let will_approve = self.should_approve_recovery();

        if will_approve {
            self.state.recovery_approvals += 1;
            tracing::info!("Agent {} approved recovery for {}", self.name, account);

            // Store the approval in simulator storage for provenance
            let env = self.environment.lock().await;
            let approval_key = format!("recovery_approval:{}:{}", session_id, self.authority_id);
            let _ = env.effect_system().store(&approval_key, vec![1u8]).await;

            Ok(Some(AgentResponse::ApproveRecovery {
                session_id: session_id.to_string(),
                account: *account,
            }))
        } else {
            tracing::info!("Agent {} declined recovery for {}", self.name, account);
            Ok(None)
        }
    }

    /// Handle guardian ceremony (becoming a guardian for an account)
    async fn handle_guardian_ceremony(
        &mut self,
        account: &AuthorityId,
        context_id: &ContextId,
    ) -> TerminalResult<Option<AgentResponse>> {
        tracing::info!(
            "Agent {} participating in guardian ceremony for {} (context: {})",
            self.name,
            account,
            context_id
        );

        // Simulate ceremony participation delay
        let delay = self.calculate_response_delay();
        PhysicalTimeHandler::new().sleep_ms(delay / 2).await.ok();

        // Add guardian capability
        self.state.capabilities.insert(AgentCapability::Guardian {
            account_authority: *account,
            context_id: *context_id,
        });

        // Store guardian binding in simulator storage
        let env = self.environment.lock().await;
        let binding_key = format!(
            "guardian_binding:{}:{}:{}",
            account, self.authority_id, context_id
        );
        let _ = env
            .effect_system()
            .store(&binding_key, self.authority_id.to_bytes().to_vec())
            .await;

        tracing::info!(
            "Agent {} is now guardian for {} in context {}",
            self.name,
            account,
            context_id
        );

        Ok(Some(AgentResponse::AcceptGuardianBinding {
            account: *account,
            context_id: *context_id,
        }))
    }

    /// Handle phase change
    async fn handle_phase_change(
        &mut self,
        phase: &DemoPhase,
    ) -> TerminalResult<Vec<AgentResponse>> {
        let mut responses = Vec::new();

        match phase {
            DemoPhase::DeviceLoss => {
                // Send sympathetic message when Bob loses device
                let message = format!(
                    "Don't worry Bob, I'm here to help with recovery. - {}",
                    self.name
                );
                responses.push(AgentResponse::SendMessage {
                    channel: "guardians".to_string(),
                    content: message,
                });
            }
            DemoPhase::GuardianCoordination => {
                // Acknowledge entering recovery phase
                let message = format!(
                    "I've received the recovery request and am reviewing it. - {}",
                    self.name
                );
                responses.push(AgentResponse::SendMessage {
                    channel: "guardians".to_string(),
                    content: message,
                });
            }
        }

        Ok(responses)
    }

    /// Generate contextual response to a message
    async fn generate_contextual_response(&self, content: &str) -> TerminalResult<Option<String>> {
        let content_lower = content.to_lowercase();

        // Context-aware responses
        let response = if content_lower.contains("help") {
            Some(format!("I'm here to help, Bob! - {}", self.name))
        } else if content_lower.contains("lost") || content_lower.contains("device") {
            Some(format!(
                "We'll help you recover everything. - {}",
                self.name
            ))
        } else if content_lower.contains("thank") {
            Some(format!(
                "You're welcome! That's what guardians are for. - {}",
                self.name
            ))
        } else if content_lower.contains("recovery") {
            Some(format!("Your recovery is our priority. - {}", self.name))
        } else if content_lower.contains("hello") || content_lower.contains("hi") {
            let greeting = &self.config.personality.greetings
                [self.config.seed as usize % self.config.personality.greetings.len()];
            Some(format!("{} - {}", greeting, self.name))
        } else {
            // Random response based on chattiness
            let random_factor = ((self.config.seed + content.len() as u64) % 100) as f64 / 100.0;
            if random_factor < self.config.personality.chattiness {
                let responses = [
                    "That's interesting!",
                    "Good point!",
                    "I agree.",
                    "Absolutely!",
                ];
                let idx = (self.config.seed % responses.len() as u64) as usize;
                Some(format!("{} - {}", responses[idx], self.name))
            } else {
                None
            }
        };

        Ok(response)
    }

    /// Calculate response delay based on config
    fn calculate_response_delay(&self) -> u64 {
        let (min, max) = self.config.response_delay_ms;
        let range = max - min;
        let offset = self.config.seed % range;
        min + offset
    }

    /// Determine if should approve recovery
    fn should_approve_recovery(&self) -> bool {
        let random_factor = (self.config.seed % 100) as f64 / 100.0;
        random_factor < self.config.approval_probability
    }

    /// Process pending actions (called periodically by demo loop)
    pub async fn process_pending_actions(&mut self) -> TerminalResult<()> {
        if !self.state.monitoring {
            return Ok(());
        }

        #[allow(clippy::disallowed_methods)]
        {
            self.state.last_action_time = Some(Instant::now());
        }

        Ok(())
    }

    /// Get agent statistics
    pub fn get_statistics(&self) -> AgentStatistics {
        AgentStatistics {
            name: self.name.clone(),
            authority_id: self.authority_id,
            device_id: self.device_id,
            monitoring: self.state.monitoring,
            capabilities: self.state.capabilities.iter().cloned().collect(),
            recovery_approvals: self.state.recovery_approvals,
            messages_sent: self.state.messages_sent,
            current_phase: self.state.current_phase.clone(),
            uptime: self
                .state
                .last_action_time
                .map(|t| t.elapsed())
                .unwrap_or_default(),
        }
    }
}

/// Agent statistics for monitoring
#[derive(Debug, Clone)]
pub struct AgentStatistics {
    /// Agent name
    pub name: String,
    /// Authority identifier
    pub authority_id: AuthorityId,
    /// Device identifier
    pub device_id: DeviceId,
    /// Whether monitoring is active
    pub monitoring: bool,
    /// Current capabilities
    pub capabilities: Vec<AgentCapability>,
    /// Number of recovery approvals
    pub recovery_approvals: usize,
    /// Number of messages sent
    pub messages_sent: usize,
    /// Current demo phase
    pub current_phase: Option<DemoPhase>,
    /// Uptime duration
    pub uptime: std::time::Duration,
}

/// Factory for creating agent pairs
pub struct AgentFactory;

impl AgentFactory {
    /// Create Alice and Carol agents for demo with optional shared transport
    pub async fn create_demo_agents(
        seed: u64,
        shared_inbox: Option<Arc<std::sync::RwLock<Vec<aura_core::effects::TransportEnvelope>>>>,
    ) -> TerminalResult<(SimulatedAgent, SimulatedAgent)> {
        let alice_config = AgentConfig {
            seed,
            response_delay_ms: (1500, 3000), // Alice is relatively quick
            approval_probability: 0.98,      // Very reliable
            message_frequency_ms: 15000,
            verbose_logging: true,
            personality: AgentPersonality {
                chattiness: 0.4,
                style: vec!["warm".to_string(), "supportive".to_string()],
                greetings: vec![
                    "Hello Bob!".to_string(),
                    "Hi there!".to_string(),
                    "Hey Bob!".to_string(),
                ],
            },
        };

        let carol_config = AgentConfig {
            seed: seed + 1,
            response_delay_ms: (2000, 4000), // Carol is more deliberate
            approval_probability: 0.95,      // Also reliable
            message_frequency_ms: 20000,
            verbose_logging: true,
            personality: AgentPersonality {
                chattiness: 0.25,
                style: vec!["thoughtful".to_string(), "careful".to_string()],
                greetings: vec!["Greetings Bob!".to_string(), "Hello!".to_string()],
            },
        };

        let alice = SimulatedAgent::new_with_shared_transport(
            "Alice".to_string(),
            alice_config,
            shared_inbox.clone(),
        )
        .await?;
        let carol = SimulatedAgent::new_with_shared_transport(
            "Carol".to_string(),
            carol_config,
            shared_inbox,
        )
        .await?;

        Ok((alice, carol))
    }

    /// Create agents with custom configs
    pub async fn create_custom_agents(
        configs: Vec<(String, AgentConfig)>,
    ) -> TerminalResult<Vec<SimulatedAgent>> {
        let mut agents = Vec::new();

        for (name, config) in configs {
            let agent = SimulatedAgent::new(name, config).await?;
            agents.push(agent);
        }

        Ok(agents)
    }
}

impl std::fmt::Debug for SimulatedAgent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("SimulatedAgent")
            .field("name", &self.name)
            .field("authority_id", &self.authority_id)
            .field("device_id", &self.device_id)
            .field("config", &self.config)
            .field("state", &self.state)
            .field("environment", &"<ComposedSimulationEnvironment>")
            .finish()
    }
}

/// State tracking for recovery sessions
#[derive(Debug, Clone, Default)]
struct RecoverySessionState {
    /// Set of guardians who have approved
    approved_guardians: HashSet<String>,
    /// Required approval threshold (2-of-3 by default)
    threshold: u32,
}

/// Bridge that connects TUI EffectCommands to simulated agents
///
/// This is the key integration point - it routes commands from Bob's TUI
/// to the simulated Alice and Carol agents, and routes their responses
/// back to the TUI as AuraEvents.
pub struct SimulatedBridge {
    /// Channel to send events to agents
    agent_event_tx: broadcast::Sender<AgentEvent>,

    /// Channel to receive responses from agents
    response_rx: Arc<Mutex<mpsc::UnboundedReceiver<(AuthorityId, AgentResponse)>>>,

    /// Channel to emit events to the TUI
    tui_event_tx: broadcast::Sender<AuraEvent>,

    /// Bob's authority ID (for filtering)
    bob_authority: AuthorityId,

    /// Optional AMP channel handler (simulation or production)
    amp: Option<Arc<dyn aura_core::effects::amp::AmpChannelEffects + Send + Sync>>,

    /// Recovery session state tracking
    recovery_state: Arc<Mutex<RecoverySessionState>>,
}

impl SimulatedBridge {
    /// Subscribe to events matching a filter
    pub fn subscribe(&self, filter: EventFilter) -> EventSubscription {
        EventSubscription::new(self.tui_event_tx.subscribe(), filter)
    }

    /// Subscribe to all events
    pub fn subscribe_all(&self) -> EventSubscription {
        self.subscribe(EventFilter::all())
    }

    /// Emit an event to TUI subscribers
    pub fn emit(&self, event: AuraEvent) {
        let _ = self.tui_event_tx.send(event);
    }

    /// Dispatch a command (routes to agents and processes responses)
    pub async fn dispatch(&self, command: EffectCommand) -> Result<(), String> {
        self.route_command(&command).await;
        self.process_responses().await;
        Ok(())
    }

    /// Dispatch a command and wait for completion
    pub async fn dispatch_and_wait(&self, command: EffectCommand) -> Result<(), String> {
        self.dispatch(command).await
    }

    /// Check if connected (always true for simulation)
    pub async fn is_connected(&self) -> bool {
        true
    }

    /// Get last error (none for simulation)
    pub async fn last_error(&self) -> Option<String> {
        None
    }

    /// Create a new simulated bridge
    pub fn new(
        bob_authority: AuthorityId,
        amp: Option<Arc<dyn aura_core::effects::amp::AmpChannelEffects + Send + Sync>>,
    ) -> (Self, mpsc::UnboundedSender<(AuthorityId, AgentResponse)>) {
        let (agent_event_tx, _) = broadcast::channel(100);
        let (response_tx, response_rx) = mpsc::unbounded_channel();
        let (tui_event_tx, _) = broadcast::channel(100);

        let bridge = Self {
            agent_event_tx,
            response_rx: Arc::new(Mutex::new(response_rx)),
            tui_event_tx,
            bob_authority,
            amp,
            recovery_state: Arc::new(Mutex::new(RecoverySessionState {
                approved_guardians: HashSet::new(),
                threshold: 2, // Default 2-of-3
            })),
        };

        (bridge, response_tx)
    }

    /// Subscribe to agent events (for agents to receive)
    pub fn subscribe_agent_events(&self) -> broadcast::Receiver<AgentEvent> {
        self.agent_event_tx.subscribe()
    }

    /// Send an agent event to Alice/Carol
    ///
    /// Used by the TUI event forwarder to route events from Bob's TUI
    /// to the simulated agents.
    pub fn send_agent_event(&self, event: AgentEvent) {
        let _ = self.agent_event_tx.send(event);
    }

    /// Subscribe to TUI events (for TUI to receive)
    pub fn subscribe_tui_events(&self) -> broadcast::Receiver<AuraEvent> {
        self.tui_event_tx.subscribe()
    }

    /// Route an EffectCommand from the TUI to agents
    pub async fn route_command(&self, command: &EffectCommand) {
        match command {
            EffectCommand::SendMessage { channel, content } => {
                if let Some(amp) = &self.amp {
                    let context = ids::context_id("demo:chat-context");
                    let channel_id = ChannelId::from_str(channel)
                        .unwrap_or_else(|_| ChannelId::from_bytes(hash(channel.as_bytes())));
                    let params = aura_core::effects::amp::ChannelSendParams {
                        context,
                        channel: channel_id,
                        sender: self.bob_authority,
                        plaintext: content.as_bytes().to_vec(),
                        reply_to: None,
                    };
                    let _ = amp.send_message(params).await;
                }
                // Bob sent a message - route to agents
                let event = AgentEvent::MessageReceived {
                    from: self.bob_authority,
                    channel: channel.clone(),
                    content: content.clone(),
                };
                let _ = self.agent_event_tx.send(event);
            }
            EffectCommand::CreateChannel {
                name,
                topic,
                members,
            } => {
                if let Some(amp) = &self.amp {
                    let context = ids::context_id("demo:chat-context");
                    let params = aura_core::effects::amp::ChannelCreateParams {
                        context,
                        channel: None,
                        skip_window: None,
                        topic: topic.clone(),
                    };
                    if let Ok(channel_id) = amp.create_channel(params).await {
                        let channel = crate::tui::Channel {
                            id: channel_id,
                            name: name.clone(),
                            topic: topic.clone(),
                            channel_type: aura_app::ChannelType::Block,
                            unread_count: 0,
                            is_dm: members.len() == 1,
                            member_count: (members.len() as u32).saturating_add(1),
                            last_message: None,
                            last_message_time: None,
                            last_activity: std::time::SystemTime::now()
                                .duration_since(std::time::UNIX_EPOCH)
                                .unwrap_or_default()
                                .as_millis() as u64,
                        };
                        let _ = self
                            .tui_event_tx
                            .send(AuraEvent::ChannelCreated { channel });
                    }
                }
            }
            EffectCommand::CloseChannel { channel } => {
                if let Some(amp) = &self.amp {
                    let context = ids::context_id("demo:chat-context");
                    let channel_id = ChannelId::from_str(channel)
                        .unwrap_or_else(|_| ChannelId::from_bytes(hash(channel.as_bytes())));
                    let params = aura_core::effects::amp::ChannelCloseParams {
                        context,
                        channel: channel_id,
                    };
                    let _ = amp.close_channel(params).await;
                }
                let _ = self.tui_event_tx.send(AuraEvent::ChannelClosed {
                    channel_id: channel.clone(),
                });
            }
            EffectCommand::StartRecovery => {
                // Bob initiated recovery - notify agents
                let session_id = ids::uuid("demo-recovery-session");
                let context_id = ids::context_id("demo-recovery-context");
                let event = AgentEvent::RecoveryRequested {
                    account: self.bob_authority,
                    session_id: session_id.to_string(),
                    context_id,
                };
                let _ = self.agent_event_tx.send(event);
            }
            EffectCommand::InviteGuardian { contact_id } => {
                // Bob invited a contact to become a guardian - trigger ceremony
                if let Some(contact_id) = contact_id {
                    let context_id = ids::context_id(&format!("demo-guardian-{}", contact_id));
                    tracing::info!(
                        "Demo: Bob inviting {} to be guardian, initiating ceremony",
                        contact_id
                    );
                    let event = AgentEvent::GuardianCeremonyStarted {
                        account: self.bob_authority,
                        context_id,
                    };
                    let _ = self.agent_event_tx.send(event);
                }
            }
            _ => {
                // Other commands don't need agent routing
            }
        }
    }

    /// Process agent responses and emit TUI events
    pub async fn process_responses(&self) {
        let mut rx = self.response_rx.lock().await;

        while let Ok((authority_id, response)) = rx.try_recv() {
            match response {
                AgentResponse::SendMessage { channel, content } => {
                    let event = AuraEvent::MessageReceived {
                        channel,
                        from: authority_id.to_string(),
                        content,
                        timestamp: std::time::SystemTime::now()
                            .duration_since(std::time::UNIX_EPOCH)
                            .unwrap_or_default()
                            .as_millis() as u64,
                    };
                    let _ = self.tui_event_tx.send(event);
                }
                AgentResponse::ApproveRecovery {
                    session_id: _,
                    account: _,
                } => {
                    // Track this guardian's approval
                    let guardian_id = authority_id.to_string();
                    let (current, threshold) = {
                        let mut state = self.recovery_state.lock().await;
                        state.approved_guardians.insert(guardian_id.clone());
                        (state.approved_guardians.len() as u32, state.threshold)
                    };

                    tracing::info!(
                        "Guardian {} approved recovery ({}/{})",
                        guardian_id,
                        current,
                        threshold
                    );

                    // Emit guardian approval event with accurate count
                    let event = AuraEvent::GuardianApproved {
                        guardian_id,
                        current,
                        threshold,
                    };
                    let _ = self.tui_event_tx.send(event);

                    // Check if threshold reached
                    if current >= threshold {
                        tracing::info!("Recovery threshold reached! ({}/{})", current, threshold);
                        let _ = self.tui_event_tx.send(AuraEvent::RecoveryCompleted {
                            session_id: "demo-recovery".to_string(),
                        });
                    }
                }
                AgentResponse::AcceptGuardianBinding {
                    account,
                    context_id,
                } => {
                    tracing::info!(
                        "Guardian binding accepted: {} is now guardian for {} in {}",
                        authority_id,
                        account,
                        context_id
                    );
                }
            }
        }
    }

    /// Reset recovery state (for new recovery sessions)
    pub async fn reset_recovery_state(&self) {
        let mut state = self.recovery_state.lock().await;
        state.approved_guardians.clear();
    }

    /// Take the response receiver for external consumption
    ///
    /// This is used by DemoSignalCoordinator to receive agent responses
    /// directly instead of going through process_responses().
    /// Can only be called once - returns None after first call.
    pub async fn take_response_receiver(
        &self,
    ) -> Option<mpsc::UnboundedReceiver<(AuthorityId, AgentResponse)>> {
        // We need to swap out the receiver with a dummy one
        // This is a one-time operation
        let mut rx_guard = self.response_rx.lock().await;

        // Create a new dummy channel just to get a receiver
        let (_, dummy_rx) = mpsc::unbounded_channel();

        // Swap the receivers
        Some(std::mem::replace(&mut *rx_guard, dummy_rx))
    }

    /// Notify agents of phase change
    pub fn notify_phase_change(&self, phase: DemoPhase) {
        let event = AgentEvent::PhaseChanged { new_phase: phase };
        let _ = self.agent_event_tx.send(event);
    }

    /// Initiate guardian ceremony for agents
    pub fn initiate_guardian_ceremony(&self, account: AuthorityId, context_id: ContextId) {
        let event = AgentEvent::GuardianCeremonyStarted {
            account,
            context_id,
        };
        let _ = self.agent_event_tx.send(event);
    }
}
