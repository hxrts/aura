# Clippy configuration for Aura - Enforces effects system and hash trait usage
# See: https://doc.rust-lang.org/clippy/configuration.html

# Enforce effects system for deterministic testing
# Ban direct usage of time, randomness, UUID generation, and direct hashing

# Ban direct time access patterns
disallowed-methods = [
    # Time functions - must use effects.now()
    "std::time::SystemTime::now",
    "std::time::Instant::now",
    "chrono::Utc::now",
    "chrono::Local::now",
    "chrono::offset::Utc::now",
    "chrono::offset::Local::now",

    # Random functions - must use effects.random_bytes() or effects.rng()
    "rand::random",
    "rand::thread_rng",

    # UUID functions - must use effects.gen_uuid()
    "uuid::Uuid::new_v4",
    "uuid::Builder::from_random_bytes",

    # Other non-deterministic functions
    "std::process::id",
    "std::thread::current",

    # Hashing - CENTRALIZED TRAIT STRATEGY
    # All hashing MUST go through aura_core::hash::{hash, hasher}
    # This ensures a single source of truth for the hash algorithm
    # Rationale: Allows algorithm swapping without code changes (e.g., Blake3 -> SHA-256)
    "blake3::hash",
    "sha2::digest::Digest::finalize",
    "sha256::digest",
]

# Ban direct types that bypass effects or centralized hashing
disallowed-types = [
    # These should be accessed through effects
    "rand::rngs::OsRng",
    "rand::rngs::ThreadRng",
    "getrandom::Error",

    # =========================================================================
    # BLOCKING LOCKS - Use async-safe alternatives
    # =========================================================================
    #
    # PROBLEM: Blocking locks in async code can starve the async runtime.
    # Holding a std::sync::Mutex or parking_lot::Mutex across an .await point
    # blocks the entire executor thread.
    #
    # SOLUTION: Use async-aware locks from async_lock or tokio::sync:
    #   - async_lock::Mutex / async_lock::RwLock (runtime-agnostic)
    #   - tokio::sync::Mutex / tokio::sync::RwLock (tokio-specific)
    #
    # WHERE BLOCKING LOCKS ARE ALLOWED (add #[allow(clippy::disallowed_types)]):
    #   1. aura-effects: Effect handler implementations (OS integration layer)
    #   2. aura-agent/src/runtime/: Runtime assembly and bootstrap code
    #   3. Truly synchronous code paths that NEVER cross .await boundaries
    #
    # WHERE BLOCKING LOCKS ARE FORBIDDEN:
    #   - All async trait implementations
    #   - All code in Layer 1-5 crates (aura-core through feature crates)
    #   - Any code that may be called from async context
    #
    # See docs/999_project_structure.md "Effect System and Impure Function Guidelines"
    # =========================================================================
    "std::sync::Mutex",
    "std::sync::RwLock",
    "parking_lot::Mutex",
    "parking_lot::RwLock",
    "parking_lot::FairMutex",
    "parking_lot::ReentrantMutex",

    # Hashing types - CENTRALIZED TRAIT STRATEGY
    # Direct hasher instantiation MUST go through aura_core::hash::hasher()
    # This ensures consistent algorithm usage across the codebase
    "blake3::Hasher",
    "sha2::Sha256",
    "sha256::Hasher",
]

# Performance and correctness
type-complexity-threshold = 250

# Security-focused lints
allow-unwrap-in-tests = true

# === Rust Style Guide Thresholds ===
#
# LINTS DISABLED BY DEFAULT (too noisy for active development):
#   - must_use_candidate (2000+ warnings)
#   - trivially_copy_pass_by_ref, needless_pass_by_value
#   - unused_async (trait impls often async for signature compatibility)
#   - manual_let_else, cognitive_complexity
#   - fn_params_excessive_bools, struct_excessive_bools, too_many_arguments
#
# To run a FULL STYLE AUDIT with all lints enabled:
#   cargo clippy -- -W clippy::must_use_candidate -W clippy::trivially_copy_pass_by_ref \
#                   -W clippy::needless_pass_by_value -W clippy::unused_async \
#                   -W clippy::manual_let_else -W clippy::cognitive_complexity \
#                   -W clippy::fn_params_excessive_bools -W clippy::struct_excessive_bools \
#                   -W clippy::too_many_arguments
#
# Rationale: These are aspirational style guidelines. Enable them periodically
# for code quality audits, not during active development.
#
# Thresholds (applied when lints are enabled):
#   cognitive-complexity-threshold = 25
#   max-fn-params-bools = 2
#   max-struct-bools = 2
#   too-many-arguments-threshold = 8

# Memory ยง7: large types should be passed by reference
trivial-copy-size-limit = 32
pass-by-value-size-limit = 256

# ============================================================================
# HASH TRAIT ENFORCEMENT NOTES
# ============================================================================
#
# The centralized hash trait strategy enforces the following:
#
# 1. ALL hashing must use aura_core::hash::{hash, hasher}
# 2. NO direct calls to blake3::hash(), sha2::*, or other hash algorithms
# 3. NO direct instantiation of Sha256, Blake3Hasher, or similar types
#
# This enables:
# - Single source of truth for hash algorithm (ALGORITHM constant)
# - Zero-cost algorithm swapping (change one constant, entire codebase follows)
# - Consistent cryptographic properties across all subsystems
# - Easy testing and mocking of hash implementations
#
# To change the hash algorithm globally:
# 1. Implement HashAlgorithm trait for new algorithm
# 2. Change ALGORITHM constant in aura-core/src/hash.rs
# 3. All code automatically uses new algorithm (no changes needed elsewhere)
#
# Exceptions:
# - aura-core/src/hash.rs: This module implements the trait, not subject to ban
# - aura-core/src/hash.rs tests: Test against algorithm implementations directly
# ============================================================================

# ============================================================================
# RUNTIME COUPLING RULES (8-Layer Architecture)
# ============================================================================
#
# Aura's 8-layer architecture enforces strict runtime abstraction boundaries.
# Concrete async runtimes (tokio, async-std) should only appear in specific layers.
#
# RUNTIME-AGNOSTIC LAYERS (must use effect traits, no direct tokio/async-std):
#   Layer 1: aura-core         - Effect trait definitions only
#   Layer 2: aura-journal, aura-authorization, aura-signature, aura-store,
#            aura-transport, aura-mpst, aura-macros - Domain specifications
#   Layer 3: aura-effects      - Effect implementations (may use runtime internally)
#   Layer 4: aura-protocol, aura-guards, aura-consensus, aura-amp, aura-anti-entropy
#   Layer 5: Feature crates (aura-authentication, aura-chat, aura-recovery, etc.)
#
# RUNTIME-AWARE LAYERS (may use tokio directly):
#   Layer 6: aura-agent, aura-simulator, aura-app - Runtime composition
#   Layer 7: aura-terminal - User interface with main() entry point
#   Layer 8: aura-testkit, aura-quint - Testing infrastructure
#
# EXCEPTIONS (require documented justification):
#   - Effect handler implementations in aura-effects (wrapping OS/runtime services)
#   - Runtime bootstrap code in aura-agent/src/runtime/
#   - Test harnesses that need deterministic control
#
# FORBIDDEN PATTERNS:
#   - tokio::spawn in Layer 1-5 (use TaskSpawner effect trait)
#   - tokio::time::sleep in Layer 1-5 (use TimeEffects::sleep_ms)
#   - tokio::sync::* in Layer 1-5 (use async_lock for runtime-agnostic code)
#   - Direct channel creation (use effect-injected channels)
#
# See docs/999_project_structure.md for the complete architectural specification.
# See docs/106_effect_system_and_runtime.md for effect system patterns.
# ============================================================================
